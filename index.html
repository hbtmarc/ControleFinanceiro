<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluxo Financeiro</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Suppress specific CDN warnings (development convenience) -->
    <script>
        (function(){
            const _warn = console.warn.bind(console);
            console.warn = function(...args){
                try {
                    const msg = args && args[0] ? String(args[0]) : '';
                    if (msg.indexOf('cdn.tailwindcss.com should not be used in production') !== -1) return; // ignore Tailwind production warning
                } catch(e){}
                _warn(...args);
            };
            const _error = console.error.bind(console);
            console.error = function(...args){
                try {
                    const msg = args && args[0] ? String(args[0]) : '';
                    if (msg.indexOf('Could not read source map for https://cdn.jsdelivr.net/npm/chart.js') !== -1) return; // ignore chart.js sourcemap 404 noise
                } catch(e){}
                _error(...args);
            };
        })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

    <!-- Google Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <!-- Confetti.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>

    <style>
/* Animações para KPIs principais */
.kpi-animate {
    animation: kpiPulse 0.7s;
}
@keyframes kpiPulse {
    0% { transform: scale(1); }
    30% { transform: scale(1.15); }
    60% { transform: scale(0.97); }
    100% { transform: scale(1); }
}
.kpi-animate-up {
    animation: kpiColorUp 0.7s;
    color: #16a34a !important; /* verde entradas */
}
.kpi-animate-down {
    animation: kpiColorDown 0.7s;
    color: #dc2626 !important; /* vermelho */
}
@keyframes kpiColorUp {
    0% { color: #16a34a; }
    80% { color: #16a34a; }
    100% { color: #1d1d1f; }
}
@keyframes kpiColorDown {
    0% { color: #dc2626; }
    80% { color: #dc2626; }
    100% { color: #1d1d1f; }
}
        /* Deduplicated KPI animations (defined above) */
        :root {
            --background-color: #f8f8fa;
            --card-background: rgba(255, 255, 255, 0.9);
            --text-primary: #1d1d1f;
            --text-secondary: #6e6e73;
            --accent-blue: #0A84FF;
            --accent-blue-hover: #0077ED;
            --progress-bar-bg: #e5e7eb;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
        }

        dialog, .report-modal {
            /* Slightly larger max-height to allow more content without inner scroll */
            max-height: 95vh;
        }

        /* Class applied to expand the transaction modal vertically when needed (e.g., salary details) */
        .modal-expanded {
            /* Allow modal to grow with content but cap to avoid overflowing the viewport */
            max-height: 90vh !important;
            overflow: auto;
            transition: max-height 220ms ease;
        }
        
        dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
        }
        
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            vertical-align: middle;
        }

        .card {
            background-color: var(--card-background);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            transition: box-shadow 0.25s ease-in-out;
        }

        .card:hover {
            box-shadow: 0 10px 20px rgba(0,0,0,0.05);
        }
        
        .btn-primary {
            background-color: var(--accent-blue);
            color: white;
            transition: background-color 0.2s ease;
        }
        .btn-primary:hover {
            background-color: var(--accent-blue-hover);
        }

        .hidden { display: none !important; }

        /* Infrequent controls (import/export) are hidden by default and shown on hover of the monthly report */
        .infrequent-controls {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.18s ease;
        }
        .infrequent-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        /* Expenses filter popover base styles */
        #expenses-filter-popover { z-index: 11000; border-radius: 0.75rem; padding: 0.6rem; min-width: 240px; background: #fff; box-shadow: 0 8px 24px rgba(13, 38, 59, 0.06); }
        #expenses-filter-popover h3 { margin: 0 0 6px 0; font-weight: 600; }
        #expenses-filter-popover label { color: var(--text-secondary); margin-bottom: 4px; display:block; }
        #expenses-filter-popover .material-symbols-outlined { vertical-align: middle; }
        #expenses-filter-popover.mobile-visible {
            position: fixed !important;
            left: 0.6rem !important;
            right: 0.6rem !important;
            bottom: 4.5rem !important;
            max-height: 40vh !important;
            overflow: auto !important;
            opacity: 1 !important;
            pointer-events: auto !important;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.08) !important;
            border-radius: 0.75rem !important;
        }
        /* Toast fade transitions */
        #toast { transition: opacity 0.25s ease, transform 0.2s ease; }
        #toast[style*="display: none"] { opacity: 0; transform: translateY(6px); }

        @keyframes slideInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        dialog[open] { animation: slideInUp 0.3s ease-out forwards; }
        
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        tbody tr.animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .tab-active {
             background-color: var(--accent-blue);
             color: white;
             box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Smooth transitions for modal type toggles and content sections */
        .modal-type-toggle {
            transition: background-color 180ms ease, color 180ms ease, transform 180ms ease;
        }
        .section-fade {
            transition: opacity 220ms ease, transform 220ms ease;
            opacity: 1;
            transform: translateY(0);
        }
        .section-hidden-smooth {
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 180ms ease, transform 180ms ease;
        }

        .sortable-header {
            cursor: pointer;
            user-select: none;
        }

        /* VR card: show 'Usado' only on hover of the value */
        .vr-value-group:hover .vr-used { opacity: 1 !important; }
        .delete-vr-usage-btn { background: transparent; border: none; padding: 4px; border-radius: 6px; cursor: pointer; display:inline-flex; align-items:center; justify-content:center; }
        .delete-vr-usage-btn .material-symbols-outlined { font-size: 16px; color: #dc2626; }
        .sort-icon {
            opacity: 0.3;
            transition: all 0.2s ease;
            display: inline-block;
            width: 1.2em;
            font-size: 1em;
            vertical-align: text-bottom;
        }
        .sortable-header.sorted .sort-icon {
            opacity: 1;
        }
        .progress-bar {
            background-color: var(--progress-bar-bg);
            border-radius: 9999px;
            overflow: hidden;
            height: 0.75rem;
        }
        .progress-bar > div {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
        }
        tbody tr {
            transition: background-color 0.2s ease;
        }
        tbody tr:hover {
            background-color: #f0f0f5;
        }

        /* Responsive Tables - Mobile First */
        /* Mobile UX - Melhor experiência, sem impactar desktop */
        @media (max-width: 639px) {
            body {
                padding: 0 !important;
                font-size: 15px;
            }
            .max-w-7xl {
                padding: 0.5rem !important;
            }
            /* Header icon group: tighter spacing on mobile */
            header .flex.items-center.gap-4 > div { gap: 0.5rem !important; }
            #current-month-display { max-width: 180px; overflow: hidden; text-overflow: ellipsis; }
            header {
                flex-direction: column !important;
                gap: 0.5rem !important;
                margin-bottom: 1.5rem !important;
            }
            h1 {
                font-size: 1.3rem !important;
            }
            .card {
                border-radius: 1rem !important;
                box-shadow: none !important;
                padding: 1rem !important;
            }
            .tab-button {
                font-size: 0.95rem !important;
                padding: 0.7rem 0 !important;
            }
            .grid-cols-4, .sm\:grid-cols-2, .lg\:grid-cols-4 {
                grid-template-columns: 1fr !important;
            }
            #kpi-projected-balance {
                font-size: 1rem !important;
            }
            .responsive-table thead {
                display: none !important;
            }
            .responsive-table tbody, .responsive-table tr {
                display: block !important;
            }
            .responsive-table tr {
                border: 1px solid #e5e7eb;
                border-radius: 1rem;
                padding: 0.7rem;
                margin-bottom: 1rem;
                background: #fff;
            }
            /* Mobile list/card adjustments */
            .responsive-table .row-label {
                color: var(--text-secondary);
                font-size: 0.9rem !important;
                font-weight: 600;
            }
            .responsive-table .row-value {
                font-size: 1.05rem !important;
                font-weight: 700;
            }
            .responsive-table .actions-cell button { padding: 0.5rem !important; }
            .responsive-table td { padding: 0.6rem 0.5rem !important; }
            .responsive-table td {
                display: flex !important;
                justify-content: space-between !important;
                align-items: center !important;
                padding: 0.4rem 0 !important;
                border-bottom: 1px solid #f3f4f6 !important;
                text-align: right !important;
                font-size: 1rem !important;
            }
            .responsive-table td:last-child {
                border-bottom: none !important;
            }
            .responsive-table td::before {
                content: attr(data-label);
                font-weight: 600;
                text-align: left;
                padding-right: 0.7rem;
                color: var(--text-secondary);
                font-size: 0.95rem;
            }
            .responsive-table td.actions-cell {
                justify-content: flex-end !important;
            }
            /* Hide top tabs and enable bottom navigation on mobile */
            #tabs { display: none !important; }
            #mobile-bottom-nav { display: none; }
            #mobile-bottom-nav.active { display: flex !important; }
            .responsive-table td.actions-cell::before {
                display: none !important;
            }
            .responsive-table td.checkbox-cell {
                padding-top: 0.4rem !important;
                padding-bottom: 0.4rem !important;
            }
            .responsive-table td.checkbox-cell::before {
                display: none !important;
            }
            .responsive-table td.checkbox-cell input {
                margin-left: auto !important;
                width: 1.3em !important;
                height: 1.3em !important;
            }
            .btn-primary, button, input[type="submit"] {
                font-size: 1.1rem !important;
                padding: 1rem 0.5rem !important;
                border-radius: 0.7rem !important;
            }
            input, select, textarea {
                font-size: 1.1rem !important;
                padding: 0.8rem !important;
            }
            /* Mobile improvements: spacing, touch targets and mobile infrequent-controls presentation */
            .card { padding: 1rem !important; }
            .kpi-label { font-size: 0.9rem !important; }
            .kpi-value { font-size: 1.25rem !important; font-weight: 700 !important; }
            .fab { width: 56px !important; height: 56px !important; right: 1rem !important; bottom: 1.2rem !important; }
            canvas { height: 220px !important; }
            /* Make the infrequent controls appear as a bottom-sheet on mobile when visible */
            .infrequent-controls.mobile-visible {
                position: fixed !important;
                left: 0.6rem !important;
                right: 0.6rem !important;
                bottom: 0.9rem !important;
                display: flex !important;
                justify-content: center !important;
                gap: 0.5rem !important;
                padding: 0.6rem !important;
                background: white !important;
                border-radius: 12px !important;
                box-shadow: 0 -10px 30px rgba(0,0,0,0.08) !important;
                z-index: 99999 !important;
                opacity: 1 !important;
                pointer-events: auto !important;
            }
            label {
                font-size: 1rem !important;
            }
            .modal, dialog, .report-modal {
                width: 100vw !important;
                min-width: unset !important;
                border-radius: 0 !important;
                padding: 0.5rem !important;
                left: 0 !important;
                margin: 0 !important;
                max-width: 100vw !important;
            }
            .modal .absolute.top-2.right-2, dialog .absolute.top-2.right-2 {
                top: 0.5rem !important;
                right: 0.5rem !important;
                font-size: 2rem !important;
            }
            .rounded-2xl, .rounded-xl, .rounded-lg {
                border-radius: 1rem !important;
            }
            #feedback-card {
                margin-top: 0.5rem !important;
                padding: 1rem !important;
            }
            /* Center the month display and make the month-picker popover centered on mobile */
            .relative { display: block; }
            #current-month-display { display: inline-block; margin: 0 auto; text-align: center; }
            #month-picker {
                position: fixed !important;
                left: 50% !important;
                top: 18% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                width: calc(100% - 2rem) !important;
                max-width: 360px !important;
                z-index: 100000 !important;
            }
            /* Unified KPI dashboard: stack KPIs inside a single card on mobile */
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 {
                display: block !important;
            }
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 > .card {
                border-radius: 0 !important;
                border-left: none !important;
                border-right: none !important;
                margin: 0 !important;
                box-shadow: none !important;
                padding: 0.9rem 1rem !important;
                border-bottom: 1px solid rgba(0,0,0,0.04) !important;
                background: white !important;
            }
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 > .card:first-child { border-top-left-radius: 0.75rem !important; border-top-right-radius: 0.75rem !important; }
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 > .card:last-child { border-bottom-left-radius: 0.75rem !important; border-bottom-right-radius: 0.75rem !important; border-bottom: none !important; }
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 h3 { margin-bottom: 0.15rem !important; }
            .grid.grid-cols-1.sm\:grid-cols-2.lg\:grid-cols-4.gap-6 p { margin-top: 0 !important; }
            canvas {
                height: 180px !important;
            }
            html, body {
                overflow-x: hidden !important;
            }
            /* Hide desktop quick links on small screens */
            #desktop-quick-links { display: none !important; }
        }
    </style>
    <style>
    /* Mobile-only UI polish: floating action button, larger touch targets, clearer bottom nav spacing */
    @media (max-width: 639px) {
        /* Floating Add button for mobile (visible only on small screens) */
        #mobile-add-transaction-fab {
            display: inline-flex !important;
            position: fixed;
            right: 1rem;
            bottom: 5.6rem; /* above the mobile bottom nav */
            width: 64px;
            height: 64px;
            border-radius: 9999px;
            background: linear-gradient(180deg,#0ea5e9,#0369a1);
            color: white;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 20px rgba(2,6,23,0.18);
            z-index: 140000;
            border: none;
            font-size: 28px;
        }
        #mobile-add-transaction-fab:active { transform: translateY(1px); }

        /* Make small header icons and list actions larger for touch */
        header .material-symbols-outlined, .mobile-nav-btn .material-symbols-outlined { font-size: 22px !important; }
        .responsive-table td .material-symbols-outlined, .responsive-table td button { padding: 10px !important; }

        /* Improve spacing inside responsive table rows for readability */
        .responsive-table tr { padding: 0.85rem !important; }
        .responsive-table td { padding: 0.9rem 0.6rem !important; }

        /* Ensure month-picker and filter bottom-sheets have comfortable margins */
        #month-picker, #expenses-filter-popover { left: 0.6rem !important; right: 0.6rem !important; bottom: 4.6rem !important; max-height: 52vh !important; }
    }
    /* Hidden by default (desktop) - shown only on mobile via media query above */
    #mobile-add-transaction-fab { display: none; }
    </style>
</head>
<body class="antialiased">

    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <!-- Cabeçalho (compact) -->
        <header class="flex flex-col sm:flex-row items-center justify-between mb-6 gap-2">
            <div class="flex items-center gap-1">
                <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 flex items-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg>
                    <span>Fluxo Financeiro</span>
                </h1>
                <div id="desktop-quick-links" class="inline-flex items-center gap-1 ml-1">
                    <button id="desktop-dashboard-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Dashboard">
                        <span class="material-symbols-outlined text-gray-600">dashboard</span>
                    </button>
                    <button id="desktop-creditcards-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Cartões">
                        <span class="material-symbols-outlined text-gray-600">credit_card</span>
                    </button>
                    <button id="desktop-investments-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Investimentos">
                        <span class="material-symbols-outlined text-gray-600">trending_up</span>
                    </button>
                    <button id="add-transaction-btn" class="bg-blue-600 p-2 rounded-full shadow-sm hover:bg-blue-700 transition-colors text-white ml-1" title="Nova Transação">
                        <span class="material-symbols-outlined">add</span>
                    </button>
                </div>
                <!-- VR KPI moved to right column (below 'Projetado' and above feedback) -->
            </div>
          <div class="flex items-center gap-2">
              <div class="flex items-center gap-2">
                    <div id="infrequent-controls" class="infrequent-controls flex items-center gap-1">
                        <button id="import-data-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Importar dados (JSON)">
                            <span class="material-symbols-outlined text-gray-600">upload</span>
                        </button>
                        <button id="export-data-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Exportar dados (JSON)">
                            <span class="material-symbols-outlined text-gray-600">download</span>
                        </button>
                    </div>
                    <input type="file" id="import-file-input" class="hidden" accept=".json">
                    <!-- Mobile toggle for import/export (visible on small screens) -->
                    <button id="mobile-infrequent-toggle" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors hidden sm:inline-flex" title="Mais opções" aria-label="Abrir opções">
                        <span class="material-symbols-outlined text-gray-600">more_horiz</span>
                    </button>
                    <button id="monthly-report-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Relatório Mensal" aria-label="Relatório Mensal">
                        <span class="material-symbols-outlined text-gray-600">assessment</span>
                    </button>
                     <button id="annual-report-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Relatório Anual" aria-label="Relatório Anual">
                        <span class="material-symbols-outlined text-gray-600">calendar_month</span>
                    </button>
                    <!-- quick links removed from this position (moved next to title) -->
                </div>
                <div class="flex items-center gap-1 card !shadow-sm !hover:scale-100 rounded-full p-0.5">
                    <button id="prev-month-btn" class="p-1.5 rounded-full transition-colors hover:bg-gray-200 active:bg-gray-300">
                        <span class="material-symbols-outlined">chevron_left</span>
                    </button>
                    <div class="relative">
                        <span id="current-month-display" class="w-36 text-center font-semibold text-gray-700 whitespace-nowrap cursor-pointer text-sm">Setembro 2025</span>
                        <!-- Month picker popover (hidden by default) -->
                        <div id="month-picker" class="hidden absolute z-50 mt-2 right-0 w-56 bg-white rounded-lg shadow-lg border border-gray-200 p-3">
                            <div class="space-y-2">
                                <label class="block text-xs text-gray-500">Mês</label>
                                <select id="month-picker-month" class="w-full border-gray-200 rounded-md p-1 text-sm">
                                    <option value="0">Janeiro</option>
                                    <option value="1">Fevereiro</option>
                                    <option value="2">Março</option>
                                    <option value="3">Abril</option>
                                    <option value="4">Maio</option>
                                    <option value="5">Junho</option>
                                    <option value="6">Julho</option>
                                    <option value="7">Agosto</option>
                                    <option value="8">Setembro</option>
                                    <option value="9">Outubro</option>
                                    <option value="10">Novembro</option>
                                    <option value="11">Dezembro</option>
                                </select>
                                <label class="block text-xs text-gray-500">Ano</label>
                                <select id="month-picker-year" class="w-full border-gray-200 rounded-md p-1 text-sm"></select>
                                <div class="flex justify-end gap-2 pt-2">
                                    <button id="month-picker-cancel" type="button" class="px-3 py-1 text-sm rounded bg-gray-100 hover:bg-gray-200">Cancelar</button>
                                    <button id="month-picker-apply" type="button" class="px-3 py-1 text-sm rounded bg-blue-600 text-white hover:bg-blue-700">Ir</button>
                                </div>
                            </div>
                        </div>
                        <!-- Expenses Filter Popover -->
                        <div id="expenses-filter-popover" class="hidden absolute z-50 bg-white rounded-lg shadow-lg border border-gray-200 p-4 w-64">
                            <h3 class="text-sm font-semibold mb-2">Filtrar Despesas</h3>
                            <div class="space-y-2 text-sm">
                                <label class="block">Pagamento</label>
                                <select id="filter-payment-method" class="w-full border-gray-200 rounded-md p-1 text-sm">
                                    <option value="">Todos</option>
                                </select>
                                    <label class="block">Essencialidade</label>
                                    <select id="filter-spending-type" class="w-full border-gray-200 rounded-md p-1 text-sm">
                                        <option value="">Todos</option>
                                        <option value="essencial">Essencial</option>
                                        <option value="nao-essencial">Não Essencial</option>
                                        <option value="reserva">Reserva</option>
                                    </select>
                                <label class="block">Categoria</label>
                                <select id="filter-category" class="w-full border-gray-200 rounded-md p-1 text-sm">
                                    <option value="">Todas</option>
                                </select>
                                <label class="block">Tipo</label>
                                <select id="filter-type" class="w-full border-gray-200 rounded-md p-1 text-sm">
                                    <option value="">Todos</option>
                                    <option value="expense">Despesa</option>
                                    <option value="saving">Reserva</option>
                                </select>
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="filter-recurring" /> <label for="filter-recurring" class="text-sm">Recorrente</label>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="filter-installment" /> <label for="filter-installment" class="text-sm">Parcelada / Financiamento</label>
                                </div>
                                <div class="flex justify-end gap-2 pt-2">
                                    <button id="filter-clear-btn" class="px-3 py-1 text-sm rounded bg-gray-100 hover:bg-gray-200">Limpar</button>
                                    <button id="filter-apply-btn" class="px-3 py-1 text-sm rounded bg-blue-600 text-white hover:bg-blue-700">Aplicar</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button id="next-month-btn" class="p-1.5 rounded-full transition-colors hover:bg-gray-200 active:bg-gray-300">
                        <span class="material-symbols-outlined">chevron_right</span>
                    </button>
                     <button id="today-btn" class="p-1.5 rounded-full transition-colors hover:bg-gray-200 active:bg-gray-300" title="Voltar para o mês atual">
                        <span class="material-symbols-outlined">today</span>
                    </button>
                </div>
            </div>
        </header>
        
        <!-- Abas de Navegação -->
        <div class="mb-6">
            <div id="tabs" class="flex sm:hidden items-center p-0.5 space-x-1 bg-gray-200 rounded-lg max-w-lg mx-auto">
                 <button data-view="dashboard" class="tab-button w-full py-1.5 text-sm font-semibold text-gray-600 rounded-md transition-colors">Visão Geral</button>
                 <button data-view="credit-cards" class="tab-button w-full py-1.5 text-sm font-semibold text-gray-600 rounded-md transition-colors">Faturas</button>
                 <button data-view="investments" class="tab-button w-full py-1.5 text-sm font-semibold text-gray-600 rounded-md transition-colors">Investimentos</button>
            </div>
        </div>
        
        <main id="app-content">
            <!-- Conteúdo da Visão Geral (Dashboard) -->
            <div id="dashboard-view" class="space-y-8">
                <!-- KPIs -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Total de Entradas</h3>
                        <p id="kpi-total-income" class="text-2xl font-semibold text-green-600 mt-1">R$ 0,00</p>
                    </div>
                    <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Despesas (Pagas)</h3>
                        <p id="kpi-total-expenses" class="text-2xl font-semibold text-red-600 mt-1">R$ 0,00</p>
                    </div>
                     <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Reservado / Investido</h3>
                        <p id="kpi-total-savings" class="text-2xl font-semibold text-indigo-600 mt-1">R$ 0,00</p>
                    </div>
                    <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Saldo Disponível</h3>
                        <p id="kpi-balance" class="text-2xl font-semibold text-gray-800 mt-1">R$ 0,00</p>
                    </div>
                </div>
                <!-- Conteúdo Principal: Tabelas e Gráficos -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Coluna de Transações -->
                    <div class="lg:col-span-2 space-y-8">
                        <!-- Movimentações do Mês header removed; add button moved to header -->

                        <!-- Tabela de Entradas -->
                        <div class="card p-6 rounded-xl">
                            <div class="flex items-center justify-between mb-4">
                                <h2 class="text-xl font-semibold">Entradas</h2>
                                <div id="vr-badge" class="text-sm text-gray-600"></div>
                            </div>
                             <div class="overflow-x-auto">
                                <table class="w-full text-left responsive-table">
                                    <thead><tr class="border-b border-gray-200">
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500">Descrição</th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500">Valor</th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 text-right">Ações</th>
                                    </tr></thead>
                                    <tbody id="income-table-body"></tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Tabela de Despesas -->
                        <div class="card p-6 rounded-xl">
                             <div class="flex items-center justify-between mb-4">
                                <h2 class="text-xl font-semibold">Despesas</h2>
                                <div class="flex items-center gap-2">
                                    <input type="search" id="search-description" placeholder="Pesquisar despesas..." class="bg-gray-100 border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-40 p-2.5">
                                    <button id="expenses-filter-btn" class="bg-white/80 p-2 rounded-full shadow-sm hover:bg-gray-100 transition-colors" title="Filtrar despesas">
                                        <span class="material-symbols-outlined text-gray-600">filter_list</span>
                                    </button>
                                </div>
                             </div>
                             <div class="overflow-x-auto">
                                <table class="w-full text-left responsive-table">
                                    <thead id="expenses-table-head"><tr class="border-b border-gray-200">
                                        <th class="py-2 px-3"><span class="material-symbols-outlined text-gray-500 text-base">done</span></th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 sortable-header" data-sort="description">Descrição <span class="sort-icon material-symbols-outlined"></span></th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 sortable-header" data-sort="payment">Pagamento <span class="sort-icon material-symbols-outlined"></span></th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 sortable-header" data-sort="category">Categoria <span class="sort-icon material-symbols-outlined"></span></th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 sortable-header" data-sort="amount">Valor <span class="sort-icon material-symbols-outlined"></span></th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 text-right">Ações</th>
                                    </tr></thead>
                                    <tbody id="expenses-table-body"></tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Tabela de Reservas -->
                        <div class="card p-6 rounded-xl">
                            <h2 class="text-xl font-semibold mb-4">Reservas e Investimentos</h2>
                            <div class="overflow-x-auto">
                                <table class="w-full text-left responsive-table">
                                    <thead><tr class="border-b border-gray-200">
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500">Descrição</th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500">Categoria</th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500">Valor</th>
                                        <th class="py-2 px-3 font-medium text-sm text-gray-500 text-right">Ações</th>
                                    </tr></thead>
                                    <tbody id="savings-table-body"></tbody>
                                </table>
                            </div>
                        </div>
                    
                    </div>
                     <!-- Coluna de Gráficos e Insights -->
                    <div class="lg:col-span-1 space-y-8">
                        <!-- Valor Projetado do Mês (acima do feedback, visual sóbrio) -->
                        <div class="card p-3 rounded-lg mb-3 bg-gray-50 border border-gray-200">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs text-gray-500">Saldo Projetado</span>
                                <span id="kpi-projected-balance" class="text-base font-semibold text-gray-700">R$ 0,00</span>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-xs text-gray-500">Despesas Projetadas</span>
                                <span id="kpi-projected-expenses" class="text-base font-semibold text-red-600">R$ 0,00</span>
                            </div>
                        </div>
                        <!-- VR KPI: minimal — shows available balance and spent progress -->
                        <div id="kpi-vr-card" class="card p-2 rounded-xl mb-2">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h4 class="text-xs font-medium text-gray-500">VR - Uso</h4>
                                </div>
                                <div class="text-right">
                                    <!-- Show available balance (credited - used), same value as the VR card in Faturas -->
                                    <p id="kpi-vr-values" class="text-sm font-semibold text-green-600">R$ 0,00</p>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="w-full bg-gray-200 rounded h-4 overflow-hidden relative">
                                    <div id="kpi-vr-progress" class="h-4 w-0 flex items-center justify-end pr-1 text-xs text-white" style="transition: width 360ms ease;"></div>
                                    <div id="kpi-vr-bar-text" class="absolute inset-0 flex items-center justify-center text-xs text-gray-700 pointer-events-none"></div>
                                </div>
                            </div>
                        </div>
                        <!-- VT KPI: mirror VR immediately below -->
                        <div id="kpi-vt-card" class="card p-2 rounded-xl mb-2">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h4 class="text-xs font-medium text-gray-500">VT - Uso</h4>
                                </div>
                                <div class="text-right">
                                    <p id="kpi-vt-values" class="text-sm font-semibold text-yellow-600">R$ 0,00</p>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="w-full bg-gray-200 rounded h-4 overflow-hidden relative">
                                    <div id="kpi-vt-progress" class="h-4 w-0 flex items-center justify-end pr-1 text-xs text-white" style="transition: width 360ms ease;"></div>
                                    <div id="kpi-vt-bar-text" class="absolute inset-0 flex items-center justify-center text-xs text-gray-700 pointer-events-none"></div>
                                </div>
                            </div>
                        </div>
                        <div id="feedback-card" class="card p-6 rounded-xl">
                             <h2 class="text-xl font-semibold mb-2">Feedback do Mês</h2>
                             <p id="feedback-message" class="text-gray-600 text-sm mb-4">...</p>
                             <div id="feedback-visual-container" class="space-y-3"></div>
                        </div>
                        <div class="card p-6 rounded-xl">
                            <h2 class="text-xl font-semibold mb-4">Metas de Gastos</h2>
                            <div class="h-56"><canvas id="spending-goals-chart"></canvas></div>
                        </div>
                        <div class="card p-6 rounded-xl">
                            <h2 class="text-xl font-semibold mb-4">Gastos por Categoria</h2>
                            <div class="h-56"><canvas id="category-spending-chart"></canvas></div>
                        </div>
                         <div class="card p-6 rounded-xl">
                            <h2 class="text-xl font-semibold mb-4">Gastos por Pagamento</h2>
                            <div class="h-56"><canvas id="payment-method-chart"></canvas></div>
                        </div>
                         <div class="card p-6 rounded-xl">
                            <h2 class="text-xl font-semibold mb-4">Resumo Anual</h2>
                            <div class="h-56"><canvas id="annual-summary-chart"></canvas></div>
                        </div>
                        <!-- KPI Percentual de cada despesa do mês -->
                        <div class="card p-4 rounded-lg mb-4 bg-gray-50 border border-gray-200">
                            <h3 class="text-sm font-medium text-gray-500 mb-2">Percentual de cada despesa do mês</h3>
                            <div id="kpi-expense-percentuals" class="space-y-1"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Conteúdo das Faturas de Cartão -->
            <div id="credit-cards-view" class="hidden">
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-8" id="credit-cards-container"></div>
            </div>

            <!-- Conteúdo de Investimentos -->
            <div id="investments-view" class="hidden space-y-8">
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div class="card p-5 rounded-xl col-span-1 sm:col-span-2 lg:col-span-2">
                        <h3 class="text-sm font-medium text-gray-500">Patrimônio Total Acumulado</h3>
                        <p id="kpi-total-invested" class="text-3xl font-bold text-indigo-600 mt-1">R$ 0,00</p>
                    </div>
                    <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Aporte no Mês</h3>
                        <p id="kpi-monthly-investment" class="text-2xl font-semibold text-green-600 mt-1">R$ 0,00</p>
                    </div>
                    <div class="card p-5 rounded-xl">
                        <h3 class="text-sm font-medium text-gray-500">Média Mensal de Aportes</h3>
                        <p id="kpi-avg-monthly-investment" class="text-2xl font-semibold text-gray-800 mt-1">R$ 0,00</p>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="card p-6 rounded-xl">
                        <h2 class="text-xl font-semibold mb-4">Evolução dos Aportes (Ano)</h2>
                        <div class="h-80"><canvas id="monthly-savings-chart"></canvas></div>
                    </div>
                    <div class="card p-6 rounded-xl">
                        <h2 class="text-xl font-semibold mb-4">Composição da Carteira</h2>
                        <div class="h-80"><canvas id="portfolio-composition-chart"></canvas></div>
                    </div>
                </div>
                
                <div class="card p-6 rounded-xl">
                     <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold">Metas e Sonhos</h2>
                        <button id="add-goal-btn" class="btn-primary font-medium py-2 px-4 rounded-lg flex items-center gap-2 transition-transform active:scale-95">
                            <span class="material-symbols-outlined">add</span>
                            <span>Nova Meta</span>
                        </button>
                    </div>
                    <div id="goals-container" class="space-y-4"></div>
                </div>

                <div class="card p-6 rounded-xl">
                    <h2 class="text-xl font-semibold mb-4">Projeção de Crescimento (Juros de 8% a.a.)</h2>
                    <p class="text-sm text-gray-600 mb-4">Com base na sua média de aportes, seu patrimônio pode chegar a:</p>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 text-center">
                        <div>
                            <p class="text-2xl font-bold text-indigo-600" id="projection-1y">R$ 0,00</p>
                            <p class="text-sm text-gray-500">em 1 ano</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-indigo-600" id="projection-5y">R$ 0,00</p>
                            <p class="text-sm text-gray-500">em 5 anos</p>
                        </div>
                        <div>
                            <p class="text-2xl font-bold text-indigo-600" id="projection-10y">R$ 0,00</p>
                            <p class="text-sm text-gray-500">em 10 anos</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal de Transação -->
    <dialog id="transaction-modal" class="p-3 rounded-2xl shadow-2xl card w-full max-w-2xl">
        <h2 id="modal-title" class="text-2xl font-bold mb-3">Nova Transação</h2>
        <form id="transaction-form" class="space-y-2 text-sm h-full">
            <input type="hidden" id="transaction-id">
            <div id="transaction-error" role="alert" class="hidden text-sm text-red-700 bg-red-50 border border-red-100 p-2 rounded">&nbsp;</div>
            <div class="flex items-center justify-center p-1 bg-gray-200 rounded-lg mb-6">
                <button type="button" data-type="expenses" class="modal-type-toggle w-1/3 py-2 text-center rounded-md font-semibold transition-colors">Despesa</button>
                <button type="button" data-type="incomes" class="modal-type-toggle w-1/3 py-2 text-center rounded-md font-semibold transition-colors">Entrada</button>
                <button type="button" data-type="savings" class="modal-type-toggle w-1/3 py-2 text-center rounded-md font-semibold transition-colors">Reserva</button>
            </div>
            <input type="hidden" id="transaction-type-input" value="expenses">
            <div>
                <label for="description" class="block text-sm font-medium text-gray-700">Descrição</label>
                <input type="text" id="description" required class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" list="description-suggestions">
                <datalist id="description-suggestions"></datalist>
                <!-- Hint explaining when description is auto-filled/disabled (visible for VT flows) -->
                <p id="description-hint" class="text-xs text-gray-500 mt-1 hidden" aria-hidden="true">&nbsp;</p>
            </div>

            <!-- salary-section moved into advanced options for better layout -->
            <div>
                <label for="amount" class="block text-sm font-medium text-gray-700">Valor (R$)</label>
                <input type="number" id="amount" step="0.01" required class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
            </div>

            <!-- Campos Específicos -->
            <div id="expense-fields" class="space-y-4">
                 <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div>
                        <label for="payment-method" class="block text-sm font-medium text-gray-700">Forma de Pagamento</label>
                        <select id="payment-method" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></select>
                    </div>
                     <div>
                        <label for="category-expense" class="block text-sm font-medium text-gray-700">Categoria</label>
                        <select id="category-expense" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></select>
                        <!-- Hint explaining when category is auto-selected/disabled (visible for VT/VR flows) -->
                        <p id="category-hint" class="text-xs text-gray-500 mt-1 hidden" aria-hidden="true">&nbsp;</p>
                    </div>
                </div>
                <div>
                    <label for="expense-type" class="block text-sm font-medium text-gray-700">Tipo</label>
                    <select id="expense-type" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                       <option value="Essenciais">Essencial</option>
                       <option value="Não Essenciais">Não Essencial</option>
                    </select>
                </div>
            </div>

            <div id="saving-fields" class="hidden space-y-4">
                <div>
                    <label for="category-saving" class="block text-sm font-medium text-gray-700">Categoria da Reserva</label>
                    <select id="category-saving" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"></select>
                </div>
            </div>

            <!-- Opções Avançadas -->
            <div id="advanced-options" class="border-t pt-4 mt-4 space-y-4">
                 <label class="flex items-center cursor-pointer">
                    <input type="checkbox" id="is-recurring" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                    <span class="ml-2 text-sm text-gray-700">Tornar esta transação recorrente? (mensal)</span>
                </label>
                <!-- Campos específicos para Entrada: Salário (posicionados abaixo da opção recorrente) -->
                <div id="salary-section" class="hidden mt-2 space-y-1">
                    <label class="flex items-center">
                        <input type="checkbox" id="is-salary" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-700">É salário?</span>
                    </label>
                    <div id="salary-fields" class="hidden">
                        <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-1">
                            <div>
                                <label class="block text-sm text-gray-700">Salário Base (R$)</label>
                                <input type="number" id="salary-base" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-700">Periculosidade (%)</label>
                                <input type="number" id="salary-periculosidade" step="0.1" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-700">Outros Proventos (R$)</label>
                                <input type="number" id="salary-outros-proventos" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-700">Dependentes</label>
                                <input type="number" id="salary-dependentes" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" min="0">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-700">Desjejum (R$/dia)</label>
                                <input type="number" id="salary-desjejum-dia" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-700">Transporte (R$/dia)</label>
                                <input type="number" id="salary-transporte-dia" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1">
                            </div>
                        </div>

                        <details class="mt-2">
                            <summary class="cursor-pointer text-sm text-gray-700">Mais opções do salário</summary>
                            <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-1">
                                <div>
                                    <label class="block text-sm text-gray-700">Dias Trabalhados</label>
                                    <input type="number" id="salary-dias-trabalhados" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" min="0">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-700">HE Sáb (h)</label>
                                    <input type="number" id="salary-h-extra-sab" step="0.1" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" min="0">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-700">HE Dom (h)</label>
                                    <input type="number" id="salary-h-extra-dom" step="0.1" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" min="0">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-700">Jornada (h/mês)</label>
                                    <input type="number" id="salary-jornada-horas" step="1" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" value="220">
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-700">Horas trabalhadas (h)</label>
                                    <input type="number" id="salary-horas-trabalhadas" step="0.1" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm py-1" placeholder="Ex: 176">
                                </div>
                            </div>
                        </details>
                    </div>
                </div>
                <div id="installments-section" class="hidden">
                     <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="is-installment" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-700">É uma compra parcelada?</span>
                    </label>
                    <div id="installments-fields" class="hidden mt-2">
                        <label for="installments-count" class="block text-sm font-medium text-gray-700">Número de parcelas (Valor total será dividido)</label>
                        <input type="number" id="installments-count" min="2" max="48" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: 12">
                        <label for="installments-current" class="block text-sm font-medium text-gray-700 mt-2">Parcela atual (se já estiver em andamento)</label>
                        <input type="number" id="installments-current" min="1" max="48" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: 4">
                        <p class="text-xs text-gray-500 mt-1">Se >1, o valor informado será tratado como valor por parcela (não será dividido).</p>
                    </div>
                </div>
                <div id="financing-section" class="hidden">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="is-financing" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span class="ml-2 text-sm text-gray-700">É um financiamento?</span>
                    </label>
                    <div id="financing-fields" class="hidden mt-2">
                        <label for="financing-total" class="block text-sm font-medium text-gray-700">Total de parcelas</label>
                        <input type="number" id="financing-total" min="2" max="120" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: 36">
                        <label for="financing-current" class="block text-sm font-medium text-gray-700 mt-2">Parcela atual</label>
                        <input type="number" id="financing-current" min="1" max="120" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: 12">
                    </div>
                </div>
            </div>

            <div class="flex justify-end gap-4 pt-4">
                <button type="button" id="close-transaction-modal-btn" class="bg-gray-200 text-gray-800 hover:bg-gray-300 font-medium py-2 px-5 rounded-lg transition-colors">Cancelar</button>
                <button type="submit" class="btn-primary font-medium py-2 px-5 rounded-lg transition-transform active:scale-95">Salvar</button>
            </div>
        </form>
    </dialog>

     <dialog id="goal-modal" class="p-8 rounded-2xl shadow-2xl card w-full max-w-lg">
        <h2 id="goal-modal-title" class="text-2xl font-bold mb-6">Nova Meta</h2>
        <form id="goal-form" class="space-y-4">
            <input type="hidden" id="goal-id">
            <div>
                <label for="goal-name" class="block text-sm font-medium text-gray-700">Nome da Meta</label>
                <input type="text" id="goal-name" required class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: Viagem para o Japão">
            </div>
            <div>
                <label for="goal-amount" class="block text-sm font-medium text-gray-700">Valor Total (R$)</label>
                <input type="number" id="goal-amount" step="0.01" required class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="Ex: 15000">
            </div>
             <div class="flex justify-end gap-4 pt-4">
                <button type="button" id="close-goal-modal-btn" class="bg-gray-200 text-gray-800 hover:bg-gray-300 font-medium py-2 px-5 rounded-lg transition-colors">Cancelar</button>
                <button type="submit" class="btn-primary font-medium py-2 px-5 rounded-lg transition-transform active:scale-95">Salvar Meta</button>
            </div>
        </form>
    </dialog>

    <dialog id="monthly-report-modal" class="report-modal p-8 rounded-2xl shadow-2xl card w-full max-w-4xl overflow-y-auto">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">Relatório Mensal - <span id="monthly-report-title"></span></h2>
            <button type="button" id="close-monthly-report-btn" class="p-2 rounded-full hover:bg-gray-200">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        <div class="space-y-8">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Total Entradas</h3>
                    <p id="mr-total-income" class="text-xl font-semibold text-green-600 mt-1"></p>
                </div>
                 <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Total Saídas</h3>
                    <p id="mr-total-outcome" class="text-xl font-semibold text-red-600 mt-1"></p>
                </div>
                 <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Saldo Final</h3>
                    <p id="mr-final-balance" class="text-xl font-semibold mt-1"></p>
                </div>
            </div>
             <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="card p-6 rounded-xl !hover:scale-100">
                    <h3 class="text-lg font-semibold mb-4">Onde seu dinheiro foi parar?</h3>
                    <div class="h-64"><canvas id="mr-category-breakdown-chart"></canvas></div>
                </div>
                <div class="card p-6 rounded-xl !hover:scale-100">
                    <h3 class="text-lg font-semibold mb-4">Maiores Despesas do Mês</h3>
                    <ul id="mr-top-expenses-list" class="space-y-2 text-sm"></ul>
                </div>
            </div>
        </div>
    </dialog>

    <dialog id="annual-report-modal" class="report-modal p-8 rounded-2xl shadow-2xl card w-full max-w-4xl overflow-y-auto">
         <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">Relatório Anual - <span id="annual-report-title"></span></h2>
            <button type="button" id="close-annual-report-btn" class="p-2 rounded-full hover:bg-gray-200">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
         <div class="space-y-8">
             <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Total Entradas no Ano</h3>
                    <p id="ar-total-income" class="text-xl font-semibold text-green-600 mt-1"></p>
                </div>
                 <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Total Saídas no Ano</h3>
                    <p id="ar-total-outcome" class="text-xl font-semibold text-red-600 mt-1"></p>
                </div>
                 <div class="card p-4 rounded-lg text-center !hover:scale-100">
                    <h3 class="text-sm font-medium text-gray-500">Balanço Final do Ano</h3>
                    <p id="ar-final-balance" class="text-xl font-semibold mt-1"></p>
                </div>
            </div>
             <div class="card p-6 rounded-xl !hover:scale-100">
                <h3 class="text-lg font-semibold mb-4">Evolução do Saldo Mensal</h3>
                <div class="h-80"><canvas id="ar-balance-evolution-chart"></canvas></div>
            </div>
             <div class="card p-6 rounded-xl !hover:scale-100">
                <h3 class="text-lg font-semibold mb-4">Média de Gastos Mensais por Categoria</h3>
                <div class="h-80"><canvas id="ar-avg-category-spending-chart"></canvas></div>
            </div>
        </div>
    </dialog>

    <!-- VR Ledger Modal -->
    <dialog id="vr-modal" class="p-6 rounded-2xl shadow-2xl card w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">Gerenciar VR</h2>
        <form id="vr-entry-form" class="space-y-3">
            <input type="hidden" id="vr-entry-id">
            <div>
                <label class="block text-sm text-gray-700">Descrição</label>
                <input id="vr-entry-desc" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div>
                <label class="block text-sm text-gray-700">Valor (R$)</label>
                <input id="vr-entry-amount" type="number" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button id="vr-entry-cancel" type="button" class="bg-gray-100 px-3 py-1 rounded">Cancelar</button>
                <button id="vr-entry-save" type="submit" class="btn-primary px-3 py-1 rounded">Salvar</button>
            </div>
        </form>
        <button id="close-vr-modal" class="absolute top-3 right-3 p-1"> <span class="material-symbols-outlined">close</span></button>
    </dialog>
    
    <!-- VR Usage Edit Modal -->
    <dialog id="vr-usage-modal" class="p-6 rounded-2xl shadow-2xl card w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">Editar Compra (VR)</h2>
        <form id="vr-usage-form" class="space-y-3">
            <input type="hidden" id="vr-usage-id">
            <div>
                <label class="block text-sm text-gray-700">Descrição</label>
                <input id="vr-usage-desc" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div>
                <label class="block text-sm text-gray-700">Valor (R$)</label>
                <input id="vr-usage-amount" type="number" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button id="vr-usage-cancel" type="button" class="bg-gray-100 px-3 py-1 rounded">Cancelar</button>
                <button id="vr-usage-save" type="submit" class="btn-primary px-3 py-1 rounded">Salvar</button>
            </div>
        </form>
        <button id="vr-usage-close" class="absolute top-3 right-3 p-1"> <span class="material-symbols-outlined">close</span></button>
    </dialog>
    
    <!-- VT Ledger Modal -->
    <dialog id="vt-modal" class="p-6 rounded-2xl shadow-2xl card w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">Gerenciar VT</h2>
        <form id="vt-entry-form" class="space-y-3">
            <input type="hidden" id="vt-entry-id">
            <div>
                <label class="block text-sm text-gray-700">Descrição</label>
                <input id="vt-entry-desc" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div>
                <label class="block text-sm text-gray-700">Valor (R$)</label>
                <input id="vt-entry-amount" type="number" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button id="vt-entry-cancel" type="button" class="bg-gray-100 px-3 py-1 rounded">Cancelar</button>
                <button id="vt-entry-save" type="submit" class="btn-primary px-3 py-1 rounded">Salvar</button>
            </div>
        </form>
        <button id="close-vt-modal" class="absolute top-3 right-3 p-1"> <span class="material-symbols-outlined">close</span></button>
    </dialog>
    
    <!-- VT Usage Edit Modal -->
    <dialog id="vt-usage-modal" class="p-6 rounded-2xl shadow-2xl card w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">Editar Compra (VT)</h2>
        <form id="vt-usage-form" class="space-y-3">
            <input type="hidden" id="vt-usage-id">
            <div>
                <label class="block text-sm text-gray-700">Descrição</label>
                <input id="vt-usage-desc" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div>
                <label class="block text-sm text-gray-700">Valor (R$)</label>
                <input id="vt-usage-amount" type="number" step="0.01" class="mt-1 block w-full border-gray-300 rounded-md p-2" />
            </div>
            <div class="flex justify-end gap-2 pt-2">
                <button id="vt-usage-cancel" type="button" class="bg-gray-100 px-3 py-1 rounded">Cancelar</button>
                <button id="vt-usage-save" type="submit" class="btn-primary px-3 py-1 rounded">Salvar</button>
            </div>
        </form>
        <button id="vt-usage-close" class="absolute top-3 right-3 p-1"> <span class="material-symbols-outlined">close</span></button>
    </dialog>
    
    <script>
    // Global toast helper para feedback visual (disponível antes do init)
    function showToast(message, color = 'bg-blue-600') {
        let toast = document.getElementById('toast');
        if (!toast) {
            // console.debug('[toast]', message);
            return;
        }
        toast.textContent = message;
        toast.className = `${color} text-white px-4 py-2 rounded shadow-lg`;
        // Choose parent: if a dialog is open, append the toast inside it so it's above the backdrop/blur
        const openDialogs = Array.from(document.querySelectorAll('dialog[open]'));
        const parent = openDialogs.length ? openDialogs[openDialogs.length - 1] : document.body;
        try {
            if (toast.parentNode !== parent) parent.appendChild(toast);
        } catch (e) { document.body.appendChild(toast); }

        // Position relative to parent: if inside dialog, use absolute positioning; otherwise fixed to viewport
        if (parent && parent.tagName && parent.tagName.toLowerCase() === 'dialog') {
            toast.style.position = 'absolute';
            toast.style.bottom = '1rem';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            // Make sure it's above dialog content
            toast.style.zIndex = '9999';
        } else {
            toast.style.position = 'fixed';
            toast.style.bottom = '1rem';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            try { toast.style.zIndex = '130001'; } catch (e) {}
        }
        toast.style.display = 'block';
        toast.style.opacity = '1';
        toast.style.pointerEvents = 'auto';
        if (window.__toastTimeout) clearTimeout(window.__toastTimeout);
        window.__toastTimeout = setTimeout(() => { try { toast.style.display = 'none'; } catch(e){} }, 2500);
    }

    // Transaction modal inline error helpers
    function setTransactionError(msg) {
        try {
            const el = document.getElementById('transaction-error');
            if (!el) return;
            el.textContent = msg || 'Erro';
            el.classList.remove('hidden');
        } catch (e) { console.error('setTransactionError', e); }
    }
    function clearTransactionError() {
        try {
            const el = document.getElementById('transaction-error');
            if (!el) return;
            el.textContent = '';
            el.classList.add('hidden');
        } catch (e) { console.error('clearTransactionError', e); }
    }

    // Loading overlay helpers (blocks UI during long operations like sanitization/save)
    function ensureLoadingOverlay() {
        if (document.getElementById('global-loading-overlay')) return;
        const overlay = document.createElement('div');
        overlay.id = 'global-loading-overlay';
        overlay.style.position = 'fixed';
        overlay.style.left = '0';
        overlay.style.top = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.background = 'rgba(0,0,0,0.45)';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.zIndex = '120000';
    overlay.innerHTML = `<div style="display:flex;flex-direction:column;align-items:center;gap:12px;"><div class="loader" style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.15);border-top-color:white;animation: spin 1s linear infinite"></div><div style="color:white;font-weight:600">Salvando...</div></div>`;
        document.body.appendChild(overlay);
        // inject spin keyframes if not present
        if (!document.getElementById('global-loading-style')) {
            const s = document.createElement('style');
            s.id = 'global-loading-style';
            s.textContent = `@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`;
            document.head.appendChild(s);
        }
    }
    function showLoading() { try { ensureLoadingOverlay(); const o = document.getElementById('global-loading-overlay'); if (o) o.style.display = 'flex'; } catch(e) { console.error('showLoading', e); } }
    function hideLoading() { try { const o = document.getElementById('global-loading-overlay'); if (o) o.style.display = 'none'; } catch(e) { console.error('hideLoading', e); } }

    // Função para importar dados do import.json para o Firebase
    async function importJsonToFirebase() {
        try {
            // Busca o arquivo import.json via fetch
            const response = await fetch('import.json');
            if (!response.ok) throw new Error('Não foi possível carregar import.json');
            const json = await response.json();
            // O arquivo já está no formato correto, basta salvar
            if (json.financeAppDB_v10) {
                await storage.saveData(json.financeAppDB_v10);
                showToast('Dados importados com sucesso!', 'bg-green-600');
                setTimeout(() => location.reload(), 1200);
            } else {
                showToast('Estrutura do import.json inválida.', 'bg-red-600');
            }
        } catch (e) {
            showToast('Erro ao importar dados: ' + e.message, 'bg-red-600');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const importBtn = document.getElementById('import-data-btn');
        if (importBtn) {
            importBtn.addEventListener('click', importJsonToFirebase);
        }
    });
    // ETAPA 2: COLE A CONFIGURAÇÃO DO SEU FIREBASE AQUI
    // Substitua o conteúdo abaixo pelas credenciais do seu projeto Firebase.
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBRce273SxZo3EMFAoTQ5I0j82eDyIrYC4",
  authDomain: "fluxofinanceiro-marc35.firebaseapp.com",
  databaseURL: "https://fluxofinanceiro-marc35-default-rtdb.firebaseio.com",
  projectId: "fluxofinanceiro-marc35",
  storageBucket: "fluxofinanceiro-marc35.appspot.com", // CORRIGIDO
  messagingSenderId: "855674664271",
  appId: "1:855674664271:web:85ad6887626ece0dc8813a",
  measurementId: "G-NKKNQFLP00"
};


    // Inicializa o Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    const storage = {
        DB_KEY: 'financeAppDB_v10',
        loadData: async function() {
            const initialData = this.getInitialData();
            try {
                // console.debug('storage.loadData: fetching data from Firebase...');
                const snapshot = await database.ref(this.DB_KEY).get();
                if (!snapshot.exists()) {
                    // console.debug("Firebase está vazio. Inicializando com dados padrão e salvando no banco.");
                    await this.saveData(initialData);
                    return initialData;
                }
                const firebaseData = snapshot.val();
                // Garante que a estrutura base (settings, data) exista, mesclando com o padrão.
                // Isso previne erros se os dados no Firebase estiverem incompletos.
                const mergedData = {
                    settings: { ...initialData.settings, ...(firebaseData.settings || {}) },
                    data: firebaseData.data || initialData.data
                };
                // Garante que sub-propriedades críticas de settings existam
                mergedData.settings.goals = mergedData.settings.goals || [];
                mergedData.settings.paymentMethods = mergedData.settings.paymentMethods || [];
                
                // console.debug("Dados do Firebase carregados e validados com sucesso.");
                return mergedData;
            } catch (err) {
                console.error("Erro crítico ao carregar dados do Firebase. Usando estrutura de dados inicial.", err);
                return initialData; // Retorna a estrutura padrão em caso de qualquer erro de conexão/leitura.
            }
        },
        // Ensure data is safe for Firebase Realtime Database (no functions, no Dates, no circular refs)
        sanitizeForFirebase: function(obj) {
            const seen = new WeakSet();
            function sanitize(value) {
                if (value === null) return null;
                const t = typeof value;
                if (t === 'string' || t === 'number' || t === 'boolean') return value;
                if (value instanceof Date) return value.toISOString();
                if (Array.isArray(value)) return value.map(v => sanitize(v));
                if (t === 'object') {
                    if (seen.has(value)) return null; // break cycles
                    seen.add(value);
                    const out = {};
                    Object.keys(value).forEach(k => {
                        // Firebase keys cannot contain . # $ [ ]
                        if (/[.#$\[\]]/.test(k)) return; // skip invalid key
                        const v = value[k];
                        const sv = sanitize(v);
                        // Skip undefined and functions
                        if (typeof sv !== 'undefined') out[k] = sv;
                    });
                    return out;
                }
                // functions, symbols, undefined -> skip
                return undefined;
            }
            return sanitize(obj);
        },

        saveData: function(data) {
            try {
                // console.debug("Sanitizing data before saving to Firebase...");
                showLoading();
                const safe = this.sanitizeForFirebase(data);
                // Persist without verbose logging of the entire object
                return database.ref(this.DB_KEY).set(safe)
                    .then(() => { /* saved successfully */ hideLoading(); return Promise.resolve(); })
                    .catch(e => {
                        console.error("Erro ao salvar no Firebase:", e);
                        hideLoading();
                        showToast('Erro ao salvar dados no Firebase: ' + (e && e.message ? e.message : e), 'bg-red-600');
                        return Promise.reject(e);
                    });
            } catch (err) {
                console.error('Erro ao sanitizar dados antes de salvar:', err);
                hideLoading();
                showToast('Erro interno ao preparar dados para salvar.', 'bg-red-600');
                return Promise.reject(err);
            }
        },
        getInitialData: function() {
            return {
                settings: {
                    goals: [],
                    spendingGoals: [{ type: 'Essenciais', goal: 0.50 }, { type: 'Não Essenciais', goal: 0.30 }, { type: 'Reserva', goal: 0.20 }],
                    expenseCategories: ["Assinaturas", "Compras", "Contas", "Lazer", "Mercado", "Alimentação", "Saúde", "Transporte", "Outros"],
                    savingCategories: ["Reserva de Emergência", "Ações", "Fundos Imobiliários", "Criptomoedas", "Poupança", "Outros"],
                    paymentMethods: [
                        { name: "Nubank", type: "credit_card", closingDay: 3, dueDay: 10 }, 
                        { name: "Porto", type: "credit_card", closingDay: 20, dueDay: 1 },
                        { name: "Pix", type: "debit" }, { name: "BB (Débito)", type: "debit" }, { name: "Inter (Débito)", type: "debit" }
                    ],
                    feedbackMessages: [
                        { id: 'A', text: "Ótimo trabalho! Você superou sua meta de reserva este mês!" },
                        { id: 'B', text: "Missão cumprida! Suas finanças estão alinhadas com as metas." },
                        { id: 'C', text: "Atenção com os gastos não essenciais. Eles estão um pouco acima da meta." },
                        { id: 'D', text: "Os gastos essenciais superaram a meta. Vale a pena revisar." },
                        { id: 'E', text: "Sua reserva este mês foi menor que o esperado. Foco em economizar!" },
                        { id: 'F', text: "O saldo deste mês ficou negativo. Vamos repensar a estratégia." }
                    ]
                },
                data: {}
            };
        },
        propagateInitialInstallments(initialData) {}
    };
    
    const App = (function() {
    // showToast is defined globally above so it can be used before App.init()
        // STATE & UI (Private variables)
        const state = {
            currentDate: new Date(),
            appData: null,
            currentView: 'dashboard',
            sort: { key: 'description', order: 'asc' },
            filters: { searchTerm: '' }
        };

        const ui = {
            charts: {}
        };
        // in-memory session defaults for the transaction modal (do not persist)
        ui.lastTransactionDefaults = null;

        // --- HELPERS ---
        function generateUUID() {
            // Simple UUID v4 generator for local IDs
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function formatCurrency(value) {
            if (typeof value !== 'number') value = parseFloat(value) || 0;
            return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
        }

        function propagateRecurringTransactions() {
            // Ensure recurring transactions exist for months and propagate future recurrences for expenses and savings
            try {
                const today = new Date();
                // Ensure arrays exist for each month
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const monthData = state.appData.data[year][month];
                        ['incomes','expenses','savings'].forEach(type => {
                            if (!Array.isArray(monthData[type])) monthData[type] = [];
                        });
                    });
                });

                // Collect recurring templates from existing months (only for expenses and savings)
                const templates = {}; // recurringId -> { type, template }
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const monthData = state.appData.data[year][month];
                        ['expenses','savings'].forEach(type => {
                            (monthData[type] || []).forEach(item => {
                                try {
                                    if (item && item.isRecurring && item.recurringId) {
                                        if (!templates[item.recurringId]) {
                                            // create a minimal template
                                            const tpl = Object.assign({}, item);
                                            // remove id/date to avoid duplicates
                                            delete tpl.id;
                                            if (tpl.date) delete tpl.date;
                                            templates[item.recurringId] = { type, template: tpl };
                                        }
                                    }
                                } catch (e) { /* ignore malformed items */ }
                            });
                        });
                    });
                });

                // Propagate each template into the next 12 months (including current month)
                const monthsToCreate = 12;
                const added = [];
                Object.keys(templates).forEach(rid => {
                    const info = templates[rid];
                    for (let i = 0; i < monthsToCreate; i++) {
                        const target = new Date(today.getFullYear(), today.getMonth() + i, 1);
                        const y = String(target.getFullYear());
                        const m = String(String(target.getMonth() + 1).padStart(2, '0'));
                        if (!state.appData.data[y]) state.appData.data[y] = {};
                        if (!state.appData.data[y][m]) state.appData.data[y][m] = { incomes: [], expenses: [], savings: [] };
                        const md = state.appData.data[y][m];
                        // Ensure the array exists
                        if (!Array.isArray(md[info.type])) md[info.type] = [];
                        // If an entry with same recurringId already exists in that month, skip
                        const exists = (md[info.type] || []).some(it => it && it.recurringId === rid);
                        if (!exists) {
                            const clone = Object.assign({}, info.template);
                            clone.id = generateUUID();
                            clone.recurringId = rid;
                            // prefer to set a normalized date on the transaction (first day of month)
                            clone.date = new Date(target.getFullYear(), target.getMonth(), 1).toISOString();
                            // default isPaid to false for future months
                            clone.isPaid = !!clone.isPaid && i === 0 ? clone.isPaid : false;
                            md[info.type].push(clone);
                            added.push({ y, m, type: info.type, id: clone.id });
                        }
                    }
                });
                if (added.length > 0) {
                    try { storage.saveData(state.appData).catch(() => {}); } catch(e){}
                }
            } catch (e) { console.error('propagateRecurringTransactions', e); }
        }

        // --- CORE FUNCTIONS ---

        async function init() {
            // console.debug("App.init() iniciado.");
            // A nova função `loadData` é robusta e sempre retorna um objeto de estado válido.
            // O `await` garante que o código abaixo só execute após o carregamento completo.
            state.appData = await storage.loadData();
            if (!state.appData) {
                console.error("Falha crítica: não foi possível carregar ou criar os dados da aplicação.");
                // Idealmente, exibir uma mensagem de erro visível para o usuário aqui.
                return;
            }
            // Normalize settings lists (alphabetical) to keep UX consistent
            try {
                const s = state.appData.settings || {};
                if (Array.isArray(s.expenseCategories)) s.expenseCategories = sortStrings(s.expenseCategories);
                if (Array.isArray(s.savingCategories)) s.savingCategories = sortStrings(s.savingCategories);
                if (Array.isArray(s.goals)) s.goals = (s.goals || []).slice().sort((a,b) => ((a.name||'').toLowerCase() < (b.name||'').toLowerCase() ? -1 : 1));
                if (Array.isArray(s.paymentMethods)) s.paymentMethods = (s.paymentMethods || []).slice().sort((a,b)=> ((a.name||'').toLowerCase() < (b.name||'').toLowerCase() ? -1 : 1));
                state.appData.settings = s;
                // Persist normalized settings in background
                storage.saveData(state.appData).catch(() => {});
            } catch(e) { /* non-fatal */ }
            // console.debug("Dados prontos para uso na aplicação:", state.appData);
            mapUI();
            bindEvents();
            // Migrate any existing VR income items into a dedicated vrLedger per month
            try {
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const md = state.appData.data[year][month];
                        if (!md) return;
                        if (!Array.isArray(md.incomes)) md.incomes = [];
                        if (!Array.isArray(md.vrLedger)) md.vrLedger = [];
                        // Ensure VT ledger exists
                        if (!Array.isArray(md.vtLedger)) md.vtLedger = [];
                        if (!Array.isArray(md.vrUsage)) md.vrUsage = [];
                        if (!Array.isArray(md.vtUsage)) md.vtUsage = [];
                        const preserved = [];
                        md.incomes.forEach(i => {
                            if (i && i.source === 'benefit-vr') {
                                md.vrLedger.push({ id: i.id || generateUUID(), amount: i.amount || 0, recurringId: i.recurringId || null, isRecurring: !!i.isRecurring, salaryMeta: i.salaryMeta || null });
                            } else preserved.push(i);
                        });
                        md.incomes = preserved;
                    });
                });
            } catch(e){ console.error('VR migration', e); }
            // Migrate any existing VT income items into vtLedger and legacy VT expenses into vtUsage
            try {
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const md = state.appData.data[year][month];
                        if (!md) return;
                        if (!Array.isArray(md.incomes)) md.incomes = [];
                        if (!Array.isArray(md.vtLedger)) md.vtLedger = [];
                        if (!Array.isArray(md.vtUsage)) md.vtUsage = [];
                        const preserved = [];
                        md.incomes.forEach(i => {
                            if (i && i.source === 'benefit-vt') {
                                md.vtLedger.push({ id: i.id || generateUUID(), amount: i.amount || 0, recurringId: i.recurringId || null, isRecurring: !!i.isRecurring, salaryMeta: i.salaryMeta || null });
                            } else preserved.push(i);
                        });
                        md.incomes = preserved;
                        // move legacy expenses paid with VT into vtUsage
                        const remainingExpenses = [];
                        md.expenses = md.expenses || [];
                        md.expenses.forEach(exp => {
                            try {
                                if (exp && (exp.payment || '').toString() === 'VT') {
                                    md.vtUsage.push({ id: exp.id || generateUUID(), amount: Number(exp.amount) || 0, description: exp.description || '', date: exp.date || new Date().toISOString() });
                                } else {
                                    remainingExpenses.push(exp);
                                }
                            } catch (e) { remainingExpenses.push(exp); }
                        });
                        md.expenses = remainingExpenses;
                    });
                });
            } catch(e) { console.error('VT migration', e); }
            // Additionally migrate any legacy expenses that used payment === 'VR' into the vrUsage ledger
            try {
                let migratedCount = 0;
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const md = state.appData.data[year][month];
                        if (!md) return;
                        if (!Array.isArray(md.expenses)) md.expenses = [];
                        if (!Array.isArray(md.vrUsage)) md.vrUsage = [];
                        // Find expenses paid with VR and move them to vrUsage
                        const remainingExpenses = [];
                        md.expenses.forEach(exp => {
                            try {
                                if (exp && (exp.payment || '').toString() === 'VR') {
                                    // preserve id if present
                                    md.vrUsage.push({ id: exp.id || generateUUID(), amount: Number(exp.amount) || 0, description: exp.description || '', date: exp.date || new Date().toISOString() });
                                    migratedCount++;
                                } else {
                                    remainingExpenses.push(exp);
                                }
                            } catch (e) { remainingExpenses.push(exp); }
                        });
                        md.expenses = remainingExpenses;
                    });
                });
                if (migratedCount > 0) {
                    // console.debug('[VR MIGRATION] moved', migratedCount, 'expenses -> vrUsage across months. Persisting migration to Firebase.');
                    // Persist state so the migration is saved
                    try { await storage.saveData(state.appData); } catch(e) { console.error('Failed to persist VR migration', e); }
                }
            } catch (e) { console.error('VR expenses migration', e); }
            goToDate(new Date());
            // console.debug("App.init() finalizado.");
        }

        function mapUI() {
            const ids = [
                'current-month-display', 'prev-month-btn', 'next-month-btn', 'today-btn', 'month-picker', 'month-picker-month', 'month-picker-year', 'month-picker-apply', 'month-picker-cancel', 
                'income-table-body', 'expenses-table-body', 'savings-table-body', 'expenses-table-head', 
                'add-transaction-btn', 'transaction-modal', 'close-transaction-modal-btn', 'transaction-form', 
                'expense-fields', 'dashboard-view', 'credit-cards-view', 'investments-view', 
                'credit-cards-container', 'installments-section', 'is-installment', 'search-description',
                'installments-fields', 'installments-current', 'payment-method', 'is-recurring', 
                'saving-fields', 'category-expense', 'category-saving', 'transaction-type-input', 
                'advanced-options', 'expense-type', 'feedback-visual-container', 'feedback-message',
                'import-data-btn', 'import-file-input', 'export-data-btn',
                'monthly-report-btn', 'annual-report-btn', 'monthly-report-modal', 'annual-report-modal',
                'desktop-dashboard-btn', 'desktop-creditcards-btn', 'desktop-investments-btn',
                'expenses-filter-btn', 'expenses-filter-popover', 'filter-payment-method', 'filter-spending-type', 'filter-category', 'filter-type', 'filter-recurring', 'filter-installment', 'filter-apply-btn', 'filter-clear-btn',
                'close-monthly-report-btn', 'close-annual-report-btn', 'add-goal-btn', 'goal-modal', 'close-goal-modal-btn',
                'goal-form', 'goals-container', 'financing-section'
            ];
            ids.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    // Mapeia para camelCase, mas garante nomes exatos para os campos críticos
                    if (id === 'installments-section') ui.installmentsSection = element;
                    else if (id === 'financing-section') ui.financingSection = element;
                    else ui[id.replace(/-./g, m => m[1].toUpperCase())] = element;
                }
            });
            ui.modalTypeToggles = document.querySelectorAll('.modal-type-toggle');
            // Map mobile bottom nav
            ui.mobileBottomNav = document.getElementById('mobile-bottom-nav');
        }

        function bindEvents() {
            ui.prevMonthBtn.addEventListener('click', () => changeMonth(-1));
            ui.nextMonthBtn.addEventListener('click', () => changeMonth(1));
            ui.todayBtn.addEventListener('click', () => goToDate(new Date()));
            // Month picker interactions
            if (ui.currentMonthDisplay) ui.currentMonthDisplay.addEventListener('click', (e) => { e.stopPropagation(); openMonthPicker(); });
            if (ui.monthPickerCancel) ui.monthPickerCancel.addEventListener('click', closeMonthPicker);
            if (ui.monthPickerApply) ui.monthPickerApply.addEventListener('click', applyMonthPicker);
            // Close picker on outside click
            document.addEventListener('click', (e) => {
                const picker = ui.monthPicker;
                if (!picker) return;
                if (picker.classList.contains('hidden')) return;
                if (!picker.contains(e.target) && e.target !== ui.currentMonthDisplay) closeMonthPicker();
            });
            ui.addTransactionBtn.addEventListener('click', () => openModal('expenses'));
            ui.closeTransactionModalBtn.addEventListener('click', () => closeModal('transaction-modal'));
            ui.transactionModal.addEventListener('click', (e) => { if(e.target === ui.transactionModal) closeModal('transaction-modal'); });
            ui.goalModal.addEventListener('click', (e) => { if(e.target === ui.goalModal) closeModal('goal-modal'); });
            ui.monthlyReportModal.addEventListener('click', (e) => { if(e.target === ui.monthlyReportModal) closeModal('monthly-report-modal'); });
            ui.annualReportModal.addEventListener('click', (e) => { if(e.target === ui.annualReportModal) closeModal('annual-report-modal'); });
            ui.transactionForm.addEventListener('submit', (e) => handleFormSubmit(e));
            // Mostrar/ocultar seção Salário quando em Entradas
            const isSalaryCheckbox = document.getElementById('is-salary');
            const salaryFields = document.getElementById('salary-fields');
            // track if we auto-checked the salary box from the description field
            let autoCheckedSalary = false;
                if (isSalaryCheckbox) {
                // two-way sync handlers
                const amountInput = document.getElementById('amount');
                const salaryBaseInput = document.getElementById('salary-base');
                let amtToSalaryHandler = null;
                let salaryToAmtHandler = null;
                const attachSync = () => {
                    try {
                        if (amountInput && salaryBaseInput) {
                            amtToSalaryHandler = function() { salaryBaseInput.value = this.value || ''; };
                            salaryToAmtHandler = function() { amountInput.value = this.value || ''; };
                            amountInput.addEventListener('input', amtToSalaryHandler);
                            salaryBaseInput.addEventListener('input', salaryToAmtHandler);
                        }
                    } catch (e) { console.error('attachSync error', e); }
                };
                const detachSync = () => {
                    try {
                        if (amountInput && amtToSalaryHandler) amountInput.removeEventListener('input', amtToSalaryHandler);
                        if (salaryBaseInput && salaryToAmtHandler) salaryBaseInput.removeEventListener('input', salaryToAmtHandler);
                        amtToSalaryHandler = null; salaryToAmtHandler = null;
                    } catch (e) { console.error('detachSync error', e); }
                };

                isSalaryCheckbox.addEventListener('change', function() {
                    if (salaryFields) salaryFields.classList.toggle('hidden', !this.checked);
                    // expand modal when salary details are visible
                    try { const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.toggle('modal-expanded', this.checked); } catch(e){}
                    if (this.checked) {
                        // ensure both fields reflect same value (prefer amount if salary-base empty)
                        try {
                            const a = parseFloat((amountInput || { value: '' }).value) || 0;
                            const s = parseFloat((salaryBaseInput || { value: '' }).value) || 0;
                            if (s === 0 && a > 0) salaryBaseInput.value = amountInput.value;
                            else if (a === 0 && s > 0) amountInput.value = salaryBaseInput.value;
                        } catch(e){}
                        attachSync();
                        // If the user checked 'É salário?', also mark transaction as recurring by default
                        const recurringCheckbox = document.getElementById('is-recurring');
                        if (recurringCheckbox) recurringCheckbox.checked = true;
                    } else {
                        detachSync();
                        // if user manually toggles off, clear auto flag
                        autoCheckedSalary = false;
                        try { const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.remove('modal-expanded'); } catch(e){}
                    }
                });
            }

            // Auto-open salary options when description contains 'salário' (with or without accent)
            const descInput = document.getElementById('description');
            if (descInput) {
                const amountInput = document.getElementById('amount');
                let amountSyncAttached = false;
                let amountSyncHandler = null;
                descInput.addEventListener('input', function() {
                    try {
                        const raw = (this.value || '');
                        const v = raw.toLowerCase();
                        // Normalize to remove diacritics for exact-match checks
                        const normalized = raw.normalize('NFD').replace(/\p{Diacritic}/gu, '').toLowerCase();
                        // contain 'salari' to be flexible with accent/case
                        const hasSalaryWord = v.indexOf('salari') !== -1;
                        const isExactSalary = /^\s*salario?s?\s*$/i.test(normalized);

                        if (hasSalaryWord) {
                            // Ensure modal is in 'incomes' type so salary-section is visible
                            if (ui.transactionTypeInput && ui.transactionTypeInput.value !== 'incomes') {
                                toggleTransactionType('incomes');
                            }
                            if (isSalaryCheckbox && !isSalaryCheckbox.checked) {
                                isSalaryCheckbox.checked = true;
                                if (salaryFields) salaryFields.classList.remove('hidden');
                                autoCheckedSalary = true;
                                // ensure recurring is checked too
                                const recurringCheckbox = document.getElementById('is-recurring');
                                if (recurringCheckbox) recurringCheckbox.checked = true;
                                // attach two-way sync if not already attached
                                try { isSalaryCheckbox.dispatchEvent(new Event('change')); } catch(e){}
                            }
                        } else {
                            // If we auto-checked earlier and the keyword was removed, revert
                            if (autoCheckedSalary && isSalaryCheckbox) {
                                isSalaryCheckbox.checked = false;
                                if (salaryFields) salaryFields.classList.add('hidden');
                                autoCheckedSalary = false;
                            }
                        }

                        // If description is exactly 'Salário' (allow accents), force both salary and recurring and sync amount -> salary-base
                        const salaryBaseInput = document.getElementById('salary-base');
                        if (isExactSalary) {
                            const recurringCheckbox = document.getElementById('is-recurring');
                            if (isSalaryCheckbox && !isSalaryCheckbox.checked) {
                                isSalaryCheckbox.checked = true;
                                if (salaryFields) salaryFields.classList.remove('hidden');
                                autoCheckedSalary = true;
                                try { isSalaryCheckbox.dispatchEvent(new Event('change')); } catch(e){}
                            }
                            if (recurringCheckbox) recurringCheckbox.checked = true;
                        }
                        if (isExactSalary && amountInput) {
                            // copy current amount value immediately
                            if (salaryBaseInput) salaryBaseInput.value = amountInput.value || '';
                            // attach sync handler if not attached
                            if (!amountSyncAttached) {
                                amountSyncHandler = function() {
                                    try { if (salaryBaseInput) salaryBaseInput.value = this.value || ''; } catch(e){}
                                };
                                amountInput.addEventListener('input', amountSyncHandler);
                                amountSyncAttached = true;
                            }
                        } else {
                            // remove sync if previously attached
                            if (amountSyncAttached && amountInput && amountSyncHandler) {
                                amountInput.removeEventListener('input', amountSyncHandler);
                                amountSyncAttached = false;
                                amountSyncHandler = null;
                            }
                        }

                    } catch (e) { console.error('description auto-salary detect error', e); }
                });
            }
            ui.modalTypeToggles.forEach(btn => btn.addEventListener('click', (e) => toggleTransactionType(e.currentTarget.dataset.type)));
            
            ui.incomeTableBody.addEventListener('click', (e) => handleTableClick(e, 'incomes'));
            ui.expensesTableBody.addEventListener('click', (e) => handleTableClick(e, 'expenses'));
            ui.savingsTableBody.addEventListener('click', (e) => handleTableClick(e, 'savings'));

            ui.importDataBtn.addEventListener('click', () => ui.importFileInput.click());
            ui.importFileInput.addEventListener('change', handleImport);
            ui.exportDataBtn.addEventListener('click', handleExport);

            ui.expensesTableHead.addEventListener('click', (e) => {
                const header = e.target.closest('.sortable-header');
                if(header) handleSort(header.dataset.sort);
            });
            document.querySelectorAll('.tab-button').forEach(button => button.addEventListener('click', (e) => changeView(e.currentTarget.dataset.view)));
            // Mobile bottom nav interactions
            if (ui.mobileBottomNav) {
                const buttons = ui.mobileBottomNav.querySelectorAll('.mobile-nav-btn');
                function updateMobileNavVisibility() {
                    if (window.innerWidth <= 639) {
                        ui.mobileBottomNav.classList.add('active');
                    } else {
                        ui.mobileBottomNav.classList.remove('active');
                    }
                }
                updateMobileNavVisibility();
                window.addEventListener('resize', updateMobileNavVisibility);
                buttons.forEach(btn => btn.addEventListener('click', (e) => changeView(e.currentTarget.dataset.view)));
            }
            ui.isInstallment.addEventListener('change', () => ui.installmentsFields.classList.toggle('hidden', !ui.isInstallment.checked));
            // Ensure financing checkbox always toggles financing fields even if payment-method change hasn't attached an onchange
            try {
                const financingCheckbox = document.getElementById('is-financing');
                if (financingCheckbox) {
                    financingCheckbox.addEventListener('change', () => {
                        const ff = document.getElementById('financing-fields');
                        if (ff) ff.classList.toggle('hidden', !financingCheckbox.checked);
                    });
                }
            } catch (e) { console.error('bindEvents attach financing handler', e); }
            ui.paymentMethod.addEventListener('change', (e) => {
                toggleInstallmentSection(e.target.value);
                try {
                    const pm = (e.target.value || '').toString();
                    const settings = state.appData.settings || {};
                    const expenseCategories = settings.expenseCategories || [];
                    const normalize = s => (s || '').toString().toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
                    const descEl = document.getElementById('description');
                    const descHint = document.getElementById('description-hint');
                    const catHint = document.getElementById('category-hint');

                    // clear hints by default
                    if (descHint) { descHint.textContent = ''; descHint.classList.add('hidden'); descHint.setAttribute('aria-hidden', 'true'); }
                    if (catHint) { catHint.textContent = ''; catHint.classList.add('hidden'); catHint.setAttribute('aria-hidden', 'true'); }

                    // VR enforcement: Alimentação / Essenciais
                    if (pm === 'VR') {
                        const foundAlim = expenseCategories.find(c => normalize(c).includes('aliment'));
                        if (foundAlim && ui.categoryExpense) {
                            ui.categoryExpense.value = foundAlim;
                            try { ui.categoryExpense.disabled = true; } catch(e){}
                        }
                        if (ui.expenseType) ui.expenseType.value = 'Essenciais';
                        // ensure description is editable for VR cases
                        try { if (descEl) descEl.disabled = false; } catch(e){}
                        // show hint explaining why category is locked
                        if (catHint) { catHint.textContent = 'Categoria padronizada para VR (Alimentação). Você pode alterar após salvar no gerenciamento de VR.'; catHint.classList.remove('hidden'); catHint.setAttribute('aria-hidden', 'false'); }
                        showToast('Pagamento via VR: categoria e tipo ajustados para Alimentação / Essencial.', 'bg-yellow-600');
                    }

                    // VT enforcement: Transporte (categoria obrigatória) + description forced to 'Abastecimento'
                    else if (pm === 'VT') {
                        const foundTransp = expenseCategories.find(c => normalize(c).includes('transport')) || expenseCategories.find(c => normalize(c).includes('transp')) || expenseCategories.find(c => normalize(c).includes('transporte'));
                        if (foundTransp && ui.categoryExpense) {
                            ui.categoryExpense.value = foundTransp;
                            try { ui.categoryExpense.disabled = true; } catch(e){}
                        }
                        if (ui.expenseType) ui.expenseType.value = 'Essenciais';
                        // Force description to 'Abastecimento' and make it readonly/disabled so it's mandatory
                        try { if (descEl) { descEl.value = 'Abastecimento'; descEl.disabled = true; } } catch(e){}
                        // show hint explaining why description and category are locked for VT
                        if (descHint) { descHint.textContent = 'Descrição obrigatória para VT: "Abastecimento". Caso precise outra descrição, registre como débito comum.'; descHint.classList.remove('hidden'); descHint.setAttribute('aria-hidden', 'false'); }
                        if (catHint) { catHint.textContent = 'Categoria padronizada para VT (Transporte). Para outras categorias, use método de pagamento diferente.'; catHint.classList.remove('hidden'); catHint.setAttribute('aria-hidden', 'false'); }
                        showToast('Pagamento via VT: categoria definida para Transporte e descrição definida para "Abastecimento".', 'bg-yellow-600');
                    }

                    // Otherwise, if changing away from VR/VT, re-enable category select and description
                    else {
                        try { if (ui.categoryExpense) ui.categoryExpense.disabled = false; } catch(e){}
                        try { if (descEl) descEl.disabled = false; } catch(e){}
                        // clear hints when normal payment selected
                        if (descHint) { descHint.textContent = ''; descHint.classList.add('hidden'); descHint.setAttribute('aria-hidden', 'true'); }
                        if (catHint) { catHint.textContent = ''; catHint.classList.add('hidden'); catHint.setAttribute('aria-hidden', 'true'); }
                    }
                } catch (err) { console.error('paymentMethod change enforcement error', err); }
            });

            ui.monthlyReportBtn.addEventListener('click', () => openMonthlyReport());
            // Desktop quick links: mirror mobile/nav tabs behavior
            if (ui.desktopDashboardBtn) ui.desktopDashboardBtn.addEventListener('click', () => changeView('dashboard'));
            if (ui.desktopCreditcardsBtn) ui.desktopCreditcardsBtn.addEventListener('click', () => changeView('credit-cards'));
            if (ui.desktopInvestmentsBtn) ui.desktopInvestmentsBtn.addEventListener('click', () => changeView('investments'));
            // Make VR KPI clickable: open Faturas (credit-cards) when clicked
            try {
                const kpiVr = document.getElementById('kpi-vr-card');
                if (kpiVr) {
                    kpiVr.style.cursor = 'pointer';
                    kpiVr.addEventListener('click', () => changeView('credit-cards'));
                }
            } catch (e) { console.error('attach kpi-vr click handler', e); }
            try {
                const kpiVt = document.getElementById('kpi-vt-card');
                if (kpiVt) {
                    kpiVt.style.cursor = 'pointer';
                    kpiVt.addEventListener('click', () => changeView('credit-cards'));
                }
            } catch (e) { console.error('attach kpi-vt click handler', e); }
            // Show import/export when hovering the monthly report icon/area
            const infrequent = document.getElementById('infrequent-controls');
            if (infrequent && ui.monthlyReportBtn) {
                let _hideTimer = null;
                ui.monthlyReportBtn.addEventListener('mouseenter', () => { clearTimeout(_hideTimer); infrequent.classList.add('visible'); });
                ui.monthlyReportBtn.addEventListener('mouseleave', () => { _hideTimer = setTimeout(() => infrequent.classList.remove('visible'), 250); });
                // Also keep visible when hovering the controls themselves
                infrequent.addEventListener('mouseenter', () => { clearTimeout(_hideTimer); infrequent.classList.add('visible'); });
                infrequent.addEventListener('mouseleave', () => { _hideTimer = setTimeout(() => infrequent.classList.remove('visible'), 250); });
            }
            // Mobile: toggle infrequent controls with a button (touch-friendly)
            const mobileToggle = document.getElementById('mobile-infrequent-toggle');
            if (mobileToggle && infrequent) {
                // Ensure the button is visible only on small screens
                mobileToggle.style.display = window.innerWidth <= 639 ? 'inline-flex' : 'none';
                mobileToggle.addEventListener('click', () => {
                    const isVisible = infrequent.classList.toggle('mobile-visible');
                    // Ensure we remove desktop hover-visible if toggling manually
                    if (isVisible) infrequent.classList.remove('visible');
                });
                // React to resize to show/hide the button appropriately
                window.addEventListener('resize', () => {
                    mobileToggle.style.display = window.innerWidth <= 639 ? 'inline-flex' : 'none';
                    if (window.innerWidth > 639) infrequent.classList.remove('mobile-visible');
                });
            }
                // Ensure charts resize on orientation change / resize
                window.addEventListener('resize', () => {
                    if (ui && ui.charts) {
                        Object.values(ui.charts).forEach(c => { try { if (c && typeof c.resize === 'function') c.resize(); } catch(e){} });
                    }
                });
            ui.annualReportBtn.addEventListener('click', () => openAnnualReport());
            ui.closeMonthlyReportBtn.addEventListener('click', () => closeModal('monthly-report-modal'));
            ui.closeAnnualReportBtn.addEventListener('click', () => closeModal('annual-report-modal'));
            ui.addGoalBtn.addEventListener('click', () => openGoalModal());
            ui.closeGoalModalBtn.addEventListener('click', () => closeModal('goal-modal'));
            ui.goalForm.addEventListener('submit', (e) => handleGoalFormSubmit(e));
            ui.searchDescription.addEventListener('input', (e) => {
                state.filters.searchTerm = e.target.value;
                renderExpenseTable();
            });

            // Expenses filter popover handlers
            if (ui.expensesFilterBtn && ui.expensesFilterPopover) {
                ui.expensesFilterBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // populate selects from settings
                    const payments = state.appData.settings.paymentMethods || [];
                    const paymentsSorted = sortStrings((payments || []).map(p => p.name || ''));
                    ui.filterPaymentMethod.innerHTML = '<option value="">Todos</option>' + paymentsSorted.map(n => `<option value="${n}">${n}</option>`).join('');
                    const cats = state.appData.settings.expenseCategories || [];
                    const catsSorted = sortStrings(cats);
                    ui.filterCategory.innerHTML = '<option value="">Todas</option>' + catsSorted.map(c => `<option value="${c}">${c}</option>`).join('');
                    // On small screens, show as mobile bottom-sheet using mobile-visible
                    if (window.innerWidth <= 639) {
                        ui.expensesFilterPopover.classList.remove('hidden');
                        ui.expensesFilterPopover.classList.add('mobile-visible');
                        ui.expensesFilterPopover.style.position = 'fixed';
                        ui.expensesFilterPopover.style.left = '0.6rem';
                        ui.expensesFilterPopover.style.right = '0.6rem';
                        ui.expensesFilterPopover.style.bottom = '4.5rem';
                        ui.expensesFilterPopover.style.top = 'auto';
                        ui.expensesFilterPopover.style.maxHeight = '40vh';
                        ui.expensesFilterPopover.style.overflow = 'auto';
                    } else {
                        // For desktop we temporarily move the popover to document.body so it won't cause scroll/layout shifts
                        try {
                            const rect = ui.expensesFilterBtn.getBoundingClientRect();
                            // Save original parent/next so we can restore later
                            if (!ui.expensesFilterPopover._origParent) {
                                ui.expensesFilterPopover._origParent = ui.expensesFilterPopover.parentNode;
                                ui.expensesFilterPopover._origNext = ui.expensesFilterPopover.nextSibling;
                            }
                            document.body.appendChild(ui.expensesFilterPopover);
                            ui.expensesFilterPopover.style.position = 'absolute';
                            ui.expensesFilterPopover.style.top = (rect.bottom + window.scrollY + 6) + 'px';
                            let left = (rect.left + window.scrollX - 160);
                            left = Math.max(8, Math.min(left, window.innerWidth - 280));
                            ui.expensesFilterPopover.style.left = left + 'px';
                            ui.expensesFilterPopover.style.right = '';
                            ui.expensesFilterPopover.classList.remove('hidden');
                            ui.expensesFilterPopover.classList.remove('mobile-visible');
                            ui.expensesFilterPopover.style.maxHeight = '';
                            ui.expensesFilterPopover.style.overflow = '';
                        } catch(e){ console.error('filter popover open error', e) }
                    }
                });

                // Close when clicking outside
                document.addEventListener('click', (ev) => {
                    if (!ui.expensesFilterPopover) return;
                    if (ui.expensesFilterPopover.classList.contains('hidden')) return;
                    if (ev.target === ui.expensesFilterBtn || ui.expensesFilterPopover.contains(ev.target)) return;
                    // hide and restore if detached
                    ui.expensesFilterPopover.classList.add('hidden');
                    ui.expensesFilterPopover.classList.remove('mobile-visible');
                    if (ui.expensesFilterPopover._origParent) {
                        try {
                            if (ui.expensesFilterPopover._origNext && ui.expensesFilterPopover._origNext.parentNode === ui.expensesFilterPopover._origParent) {
                                ui.expensesFilterPopover._origParent.insertBefore(ui.expensesFilterPopover, ui.expensesFilterPopover._origNext);
                            } else {
                                ui.expensesFilterPopover._origParent.appendChild(ui.expensesFilterPopover);
                            }
                        } catch(e) { console.error('restore popover error', e); }
                        ui.expensesFilterPopover._origParent = null; ui.expensesFilterPopover._origNext = null;
                    }
                });

                ui.filterApplyBtn.addEventListener('click', () => {
                    // Build filter object
                    state.filters.expenseFilters = state.filters.expenseFilters || {};
                    state.filters.expenseFilters.payment = ui.filterPaymentMethod.value || '';
                    state.filters.expenseFilters.spendingType = ui.filterSpendingType.value || '';
                    state.filters.expenseFilters.category = ui.filterCategory.value || '';
                    state.filters.expenseFilters.type = ui.filterType.value || '';
                    state.filters.expenseFilters.recurring = ui.filterRecurring.checked;
                    state.filters.expenseFilters.installment = ui.filterInstallment.checked;
                    ui.expensesFilterPopover.classList.add('hidden');
                    ui.expensesFilterPopover.classList.remove('mobile-visible');
                    if (ui.expensesFilterPopover._origParent) {
                        try {
                            if (ui.expensesFilterPopover._origNext && ui.expensesFilterPopover._origNext.parentNode === ui.expensesFilterPopover._origParent) {
                                ui.expensesFilterPopover._origParent.insertBefore(ui.expensesFilterPopover, ui.expensesFilterPopover._origNext);
                            } else {
                                ui.expensesFilterPopover._origParent.appendChild(ui.expensesFilterPopover);
                            }
                        } catch(e){}
                        ui.expensesFilterPopover._origParent = null; ui.expensesFilterPopover._origNext = null;
                    }
                    renderExpenseTable();
                });

                ui.filterClearBtn.addEventListener('click', () => {
                    ui.filterPaymentMethod.value = '';
                    ui.filterCategory.value = '';
                    ui.filterType.value = '';
                    ui.filterRecurring.checked = false;
                    ui.filterInstallment.checked = false;
                    state.filters.expenseFilters = {};
                    ui.expensesFilterPopover.classList.add('hidden');
                    ui.expensesFilterPopover.classList.remove('mobile-visible');
                    if (ui.expensesFilterPopover._origParent) {
                        try {
                            if (ui.expensesFilterPopover._origNext && ui.expensesFilterPopover._origNext.parentNode === ui.expensesFilterPopover._origParent) {
                                ui.expensesFilterPopover._origParent.insertBefore(ui.expensesFilterPopover, ui.expensesFilterPopover._origNext);
                            } else {
                                ui.expensesFilterPopover._origParent.appendChild(ui.expensesFilterPopover);
                            }
                        } catch(e){}
                        ui.expensesFilterPopover._origParent = null; ui.expensesFilterPopover._origNext = null;
                    }
                    renderExpenseTable();
                });
            }

            // Automação: se selecionar uma meta como categoria da reserva, preenche descrição automaticamente
            if (ui.categorySaving) {
                ui.categorySaving.addEventListener('change', function() {
                    const selected = this.value;
                    // Se for uma meta (exatamente igual ao nome de uma meta), preenche descrição
                    const goals = (state.appData.settings.goals || []).map(g => g.name);
                    // Se o valor selecionado for igual ao nome de uma meta, ou terminar com ' (Meta)', preenche
                    let metaName = null;
                    if (goals.includes(selected)) {
                        metaName = selected;
                    } else if (selected.endsWith(' (Meta)')) {
                        metaName = selected.replace(' (Meta)', '');
                    }
                    if (metaName) {
                        document.getElementById('description').value = metaName;
                    }
                });
            }
        }

        function handleExport() {
            if (!state.appData) {
                alert("Não há dados para exportar.");
                return;
            }

            // 1. Criar uma cópia profunda para não modificar o estado atual
            const appDataCopy = JSON.parse(JSON.stringify(state.appData));

            // 2. Transformar a estrutura de dados
            const transformedData = {};
            for (const year in appDataCopy.data) {
                if (Object.prototype.hasOwnProperty.call(appDataCopy.data, year)) {
                    for (const month in appDataCopy.data[year]) {
                        if (Object.prototype.hasOwnProperty.call(appDataCopy.data[year], month)) {
                            const newKey = `${year}-${month}`;
                            transformedData[newKey] = appDataCopy.data[year][month];
                        }
                    }
                }
            }
            appDataCopy.data = transformedData;

            // 3. Montar o objeto final para exportação
            const exportObject = {
                financeAppDB_v10: appDataCopy
            };

            // 4. Criar e baixar o arquivo JSON
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportObject, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "import.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            
            showToast("Dados exportados com sucesso!", 'bg-green-600');
        }

        function handleImport() {
            const fileInput = ui.importFileInput;
            const file = fileInput.files[0];
            if (!file) {
                return; // User cancelled file selection
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    const dataToSave = json.financeAppDB_v10;

                    if (!dataToSave || !dataToSave.data) {
                        throw new Error('Estrutura do JSON inválida. Chave "financeAppDB_v10" ou "data" não encontrada.');
                    }

                    // Transform data structure from {"YYYY-MM":...} to {YYYY:{MM:...}}
                    const transformedData = {};
                    for (const key in dataToSave.data) {
                        if (Object.prototype.hasOwnProperty.call(dataToSave.data, key) && key.match(/^\d{4}-\d{2}$/)) {
                            const [year, month] = key.split('-');
                            if (!transformedData[year]) {
                                transformedData[year] = {};
                            }
                            transformedData[year][month] = dataToSave.data[key];
                        }
                    }
                    dataToSave.data = transformedData;

                    await storage.saveData(dataToSave);
                    alert('Dados importados com sucesso!');
                    location.reload();
                } catch (e) {
                    alert('Erro ao importar dados: ' + e.message);
                    console.error(e);
                } finally {
                    fileInput.value = ''; // Reset input
                }
            };
            reader.readAsText(file);
        }

        // --- RENDER FUNCTIONS ---

        function render() {
            // A verificação de `appData` no início da renderização é uma boa prática final.
            if (!state.appData) {
                console.error("Renderização abortada: state.appData não está disponível.");
                return;
            }
            propagateRecurringTransactions();
            renderMonthDisplay();
            
            switch (state.currentView) {
                case 'dashboard': renderDashboard(); break;
                case 'credit-cards': renderCreditCardView(); break;
                case 'investments': renderInvestmentsView(); break;
            }
        }

        function changeView(view) {
            state.currentView = view;
            ['dashboard', 'credit-cards', 'investments'].forEach(v => {
                document.getElementById(`${v}-view`).classList.toggle('hidden', view !== v);
                document.querySelector(`.tab-button[data-view="${v}"]`).classList.toggle('tab-active', view === v);
            });
            const activeView = document.getElementById(`${view}-view`);
            activeView.classList.remove('animate-fade-in');
            void activeView.offsetWidth;
            activeView.classList.add('animate-fade-in');
            render();
        }

        function renderDashboard() {
            updateKPIs();
            renderAllTables();
            renderCharts();
        }

        function renderCreditCardView() {
            const container = ui.creditCardsContainer;
            container.innerHTML = '';
            const currentMonthData = getCurrentMonthData();
            // Render real credit cards
            const creditCards = ((state.appData.settings.paymentMethods || []).filter(p => p.type === 'credit_card')).slice().sort((a,b) => {
                const A = (a && a.name || '').toLowerCase(); const B = (b && b.name || '').toLowerCase(); return A < B ? -1 : A > B ? 1 : 0;
            });
            creditCards.forEach(card => {
                const cardExpenses = (currentMonthData.expenses || []).filter(e => e.payment === card.name);
                const totalAmount = cardExpenses.reduce((sum, exp) => sum + exp.amount, 0);
                const dueDate = new Date(state.currentDate);
                if (card.dueDay < 15) dueDate.setMonth(dueDate.getMonth() + 1);
                dueDate.setDate(card.dueDay || 1);
                container.innerHTML += `
                    <div class="card p-6 rounded-2xl shadow-sm flex flex-col">
                        <div class="flex-grow">
                            <div class="flex justify-between items-start mb-2">
                                <h3 class="text-xl font-semibold">${card.name}</h3>
                                <span class="text-xs font-medium bg-blue-100 text-blue-800 px-2 py-1 rounded-full">Venc. ${dueDate.toLocaleDateString('pt-BR', {day: '2-digit', month: '2-digit'})}</span>
                            </div>
                            <p class="text-3xl font-bold text-blue-600 mb-4">${formatCurrency(totalAmount)}</p>
                            <div class="space-y-2 max-h-48 overflow-y-auto pr-2">
                                ${cardExpenses.map(exp => {
                                    const inst = exp.totalInstallments ? `<span class="text-xs text-gray-500">(${exp.currentInstallment}/<span class="last-installment-btn" data-installment-id="${exp.installmentId}" data-total="${exp.totalInstallments}">${exp.totalInstallments}</span>)</span>` : '';
                                    const fin = (exp.financingId && exp.totalFinancing) ? `<span class="text-xs text-gray-500">(${exp.currentFinancing}/<span class="last-installment-btn" data-financing-id="${exp.financingId}" data-total="${exp.totalFinancing}">${exp.totalFinancing}</span>)</span>` : '';
                                    const remainingHtml = exp.totalInstallments ? (() => {
                                        const remainingCount = (exp.totalInstallments - (exp.currentInstallment || 1) + 1);
                                        const remainingTotal = (Number(exp.amount) || 0) * remainingCount;
                                        return `<span class="remaining-total text-xs text-gray-500 ml-2 hidden">${formatCurrency(remainingTotal)}</span>`;
                                    })() : '';
                                    return `<div class="flex justify-between text-sm items-center"><div class="desc-wrap flex items-center truncate pr-2" data-exp-id="${exp.id}" style="gap:6px;"><span class="desc-text truncate">${exp.description} ${inst} ${fin}</span>${remainingHtml}<button class="edit-cat-btn invisible ml-2" data-exp-id="${exp.id}" title="Editar categoria"><span class="material-symbols-outlined" style="font-size:16px;">edit</span></button></div><span class="font-medium flex-shrink-0">${formatCurrency(exp.amount)}</span></div>`;
                                }).join('') || '<p class="text-sm text-gray-500">Nenhum gasto este mês.</p>'}
                            </div>
                        </div>
                        <div class="mt-6">
                            <div class="flex w-full items-center" style="gap:8px;">
                                <button data-card-name="${card.name}" class="pay-invoice-btn flex-grow bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600 transition-colors">Pagar Fatura</button>
                                <button data-card-name="${card.name}" title="Adicionar despesa neste cartão" class="add-card-expense-btn flex-shrink-0 w-12 bg-blue-500 text-white font-semibold py-2 rounded-lg hover:bg-blue-600 transition-colors flex items-center justify-center"> <span class="material-symbols-outlined" style="font-size:20px; line-height:1;">add</span></button>
                            </div>
                        </div>
                    </div>`;
            });

                // If there's VR ledger balance or VR activity, render VR as a card-like payment instrument
            const vrAmount = getMonthVRBalance(currentMonthData);
            // Show VR card if there's any VR ledger entry or usage for the month,
            // even if the current available balance (credited - used) is zero.
            const hasLedger = Array.isArray(currentMonthData.vrLedger) && currentMonthData.vrLedger.length > 0;
            const hasUsage = Array.isArray(currentMonthData.vrUsage) && currentMonthData.vrUsage.length > 0;
            if (vrAmount > 0 || hasLedger || hasUsage) {
                // Derive totals: credited (sum of vrLedger) and usage (sum of vrUsage)
                // Ensure numeric conversion for safety (some entries may be strings)
                const creditedTotal = (currentMonthData.vrLedger || []).reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
                // Compute usage from vrUsage ledger entries
                let usageTotal = (currentMonthData.vrUsage || []).reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
                // Also include any expenses in the same month that were paid via VR but not recorded in vrUsage (migration edge-cases)
                try {
                    const expensesVR = (currentMonthData.expenses || []).filter(e => (e.payment || '') === 'VR');
                    const expensesVRSum = expensesVR.reduce((s, e) => s + (Number(e && e.amount) || 0), 0);
                    if (expensesVRSum > 0) usageTotal = Math.round((usageTotal + expensesVRSum) * 100) / 100;
                } catch (e) { console.error('compute expenses vr usage', e); }
                // If there are no vrUsage entries and no VR expenses but usageTotal is still > 0, this indicates a data/parsing anomaly.
                if ((!Array.isArray(currentMonthData.vrUsage) || currentMonthData.vrUsage.length === 0) && (!Array.isArray(currentMonthData.expenses) || !(currentMonthData.expenses || []).some(ex => (ex.payment || '') === 'VR')) && usageTotal > 0) {
                    console.warn('[VR WARNING] usageTotal > 0 but no vrUsage or VR expenses found. Forcing usageTotal=0. Details:', { usageTotal, vrLedger: currentMonthData.vrLedger, vrUsage: currentMonthData.vrUsage, expenses: currentMonthData.expenses });
                    usageTotal = 0;
                }
                // Debug: log ledger and usage arrays when displayAmount is zero despite credited > 0
                try { /* VR debug disabled in cleanup pass */ } catch(e) {}
                // displayAmount is credited minus expenses already charged to VR
                const displayAmount = Math.max(0, Math.round((creditedTotal - usageTotal) * 100) / 100);
                // Derive a friendly limit from latest vrLedger salaryMeta if available (kept for auxiliary info)
                let vrLimit = vrAmount;
                try {
                    const latestLedger = (currentMonthData.vrLedger || []).slice().reverse().find(l => l && l.salaryMeta);
                    if (latestLedger && latestLedger.salaryMeta && latestLedger.salaryMeta.valorDesjejumDia) {
                        // compute monthly desjejum limit as desjejumDia * diasUteis
                        const desjejumDia = Number(latestLedger.salaryMeta.valorDesjejumDia) || 0;
                        const y = state.currentDate.getFullYear();
                        const m = state.currentDate.getMonth() + 1;
                        const dias = typeof diasUteisNoMes === 'function' ? diasUteisNoMes(y, m) : 22;
                        vrLimit = Math.max(vrAmount, desjejumDia * dias);
                    }
                } catch(e) { console.error('derive vr limit', e); }

                // compute last day of the PREVIOUS month relative to the currently displayed month
                // e.g. if viewing Outubro, show last day of Setembro (30/09)
                const displayYear = state.currentDate.getFullYear();
                // Use JS Date trick: day 0 of the displayed month -> last day of previous month
                const prevMonthLastDate = new Date(displayYear, state.currentDate.getMonth(), 0);
                const lastDay = prevMonthLastDate.getDate();
                const prevMonthNumber = prevMonthLastDate.getMonth() + 1; // 1-12
                const lastDayStr = String(lastDay).padStart(2,'0') + '/' + String(prevMonthNumber).padStart(2,'0');

                container.innerHTML += `
                    <div class="card p-6 rounded-2xl shadow-sm flex flex-col bg-gradient-to-br from-green-50 to-white border border-green-200">
                        <div class="flex-grow">
                            <div class="flex justify-between items-start mb-2">
                                <h3 class="text-xl font-semibold">VR</h3>
                                <!-- Badge shows: Créd. + Último dia do mês exibido (dd/MM) -->
                                <span class="text-xs font-medium bg-green-100 text-green-800 px-2 py-1 rounded-full">Créd. ${lastDayStr}</span>
                            </div>
                            <div class="vr-value-group" title="Usado: ${formatCurrency(usageTotal)}" style="position:relative; display:inline-block;">
                                <p class="text-3xl font-bold text-green-600 mb-4" style="margin:0;">${formatCurrency(displayAmount)}</p>
                                <p class="text-sm text-gray-500 vr-used" style="margin:0; opacity:0; transition: opacity 160ms ease;">Usado: ${formatCurrency(usageTotal)}</p>
                            </div>
                            <div class="mt-3 text-sm text-gray-600">
                                <h4 class="font-semibold text-sm text-gray-700 flex items-center gap-2">
                                    <span>Compras</span>
                                    <button id="add-vr-usage-btn" type="button" class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-white border border-gray-200 text-gray-700 hover:bg-gray-50" title="Adicionar compra VR">
                                        <span class="material-symbols-outlined" style="font-size:18px;">add</span>
                                    </button>
                                </h4>
                                ${(currentMonthData.vrUsage && currentMonthData.vrUsage.length > 0) ? (() => {
                                    const usagesSorted = (currentMonthData.vrUsage || []).slice().sort((a,b) => { const A=(a.description||'').toLowerCase(); const B=(b.description||'').toLowerCase(); return A < B ? -1 : A > B ? 1 : 0; });
                                    return `<div class="space-y-1 mt-2">${usagesSorted.map(u => `<div class="flex justify-between items-center text-sm"><div class="flex items-center"><span class="truncate pr-2 cursor-pointer edit-vr-usage-trigger" data-vr-usage-edit-id="${u.id}">${u.description || 'Despesa VR'}</span></div><div class="flex items-center"><span class="font-medium mr-2">${formatCurrency(Number(u.amount)||0)}</span><button data-vr-usage-edit-id="${u.id}" class="ml-1 text-gray-600 edit-vr-usage-btn" title="Editar"><span class="material-symbols-outlined">edit</span></button><button data-vr-usage-id="${u.id}" class="ml-3 text-red-600 delete-vr-usage-btn" title="Excluir"><span class="material-symbols-outlined">delete</span></button></div></div>`).join('')}</div>`;
                                })() : '<div class="text-sm text-gray-500 mt-1">Nenhuma compra registrada.</div>'}
                            </div>
                        </div>
                                <!-- Gerenciar VR button removed per UX: VR works as débito somente -->
                    </div>`;
            }
                    // VT: mirror VR card rendering if there is VT activity
                    const vtAmount = getMonthVTBalance(currentMonthData);
                    const hasVtLedger = Array.isArray(currentMonthData.vtLedger) && currentMonthData.vtLedger.length > 0;
                    const hasVtUsage = Array.isArray(currentMonthData.vtUsage) && currentMonthData.vtUsage.length > 0;
                    if (vtAmount > 0 || hasVtLedger || hasVtUsage) {
                        const vtCreditedTotal = (currentMonthData.vtLedger || []).reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
                        let vtUsageTotal = (currentMonthData.vtUsage || []).reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
                        try {
                            const expensesVT = (currentMonthData.expenses || []).filter(e => (e.payment || '') === 'VT');
                            const expensesVTSum = expensesVT.reduce((s, e) => s + (Number(e && e.amount) || 0), 0);
                            if (expensesVTSum > 0) vtUsageTotal = Math.round((vtUsageTotal + expensesVTSum) * 100) / 100;
                        } catch (e) { console.error('compute expenses vt usage', e); }
                        if ((!Array.isArray(currentMonthData.vtUsage) || currentMonthData.vtUsage.length === 0) && (!Array.isArray(currentMonthData.expenses) || !(currentMonthData.expenses || []).some(ex => (ex.payment || '') === 'VT')) && vtUsageTotal > 0) {
                            console.warn('[VT WARNING] usageTotal > 0 but no vtUsage or VT expenses found. Forcing vtUsageTotal=0.');
                            vtUsageTotal = 0;
                        }
                        const vtDisplayAmount = Math.max(0, Math.round((vtCreditedTotal - vtUsageTotal) * 100) / 100);
                        const latestVtLedger = (currentMonthData.vtLedger || []).slice().reverse().find(l => l && l.salaryMeta);
                        // For VT, display the 5th business day of the currently viewed month (not the previous month)
                        const vtYear = state.currentDate.getFullYear();
                        const vtMonthIndex = state.currentDate.getMonth(); // 0-based
                        const daysInMonth = new Date(vtYear, vtMonthIndex + 1, 0).getDate();
                        let businessCount = 0;
                        let vtDay = 1;
                        for (; vtDay <= daysInMonth; vtDay++) {
                            const d = new Date(vtYear, vtMonthIndex, vtDay);
                            const wd = d.getDay(); // 0 = Sun, 6 = Sat
                            if (wd !== 0 && wd !== 6) businessCount++;
                            if (businessCount >= 5) break;
                        }
                        // If month has fewer than 5 business days (very unlikely), vtDay will be last available business day
                        const lastDayVT = vtDay;
                        const prevMonthNumberVT = vtMonthIndex + 1; // display month number for the viewed month
                        const lastDayStrVT = String(lastDayVT).padStart(2,'0') + '/' + String(prevMonthNumberVT).padStart(2,'0');

                        container.innerHTML += `
                            <div class="card p-6 rounded-2xl shadow-sm flex flex-col bg-gradient-to-br from-yellow-50 to-white border border-yellow-200">
                                <div class="flex-grow">
                                    <div class="flex justify-between items-start mb-2">
                                        <h3 class="text-xl font-semibold">VT</h3>
                                        <span class="text-xs font-medium bg-yellow-100 text-yellow-800 px-2 py-1 rounded-full">Créd. ${lastDayStrVT}</span>
                                    </div>
                                    <div class="vr-value-group" title="Usado: ${formatCurrency(vtUsageTotal)}" style="position:relative; display:inline-block;">
                                        <p class="text-3xl font-bold text-yellow-600 mb-4" style="margin:0;">${formatCurrency(vtDisplayAmount)}</p>
                                        <p class="text-sm text-gray-500 vr-used" style="margin:0; opacity:0; transition: opacity 160ms ease;">Usado: ${formatCurrency(vtUsageTotal)}</p>
                                    </div>
                                    <div class="mt-3 text-sm text-gray-600">
                                        <h4 class="font-semibold text-sm text-gray-700 flex items-center gap-2">
                                            <span>Compras</span>
                                            <button id="add-vt-usage-btn" type="button" class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-white border border-gray-200 text-gray-700 hover:bg-gray-50" title="Adicionar compra VT">
                                                <span class="material-symbols-outlined" style="font-size:18px;">add</span>
                                            </button>
                                        </h4>
                                        ${(currentMonthData.vtUsage && currentMonthData.vtUsage.length > 0) ? (() => {
                                            const usagesSorted = (currentMonthData.vtUsage || []).slice().sort((a,b) => { const A=(a.description||'').toLowerCase(); const B=(b.description||'').toLowerCase(); return A < B ? -1 : A > B ? 1 : 0; });
                                            return `<div class="space-y-1 mt-2">${usagesSorted.map(u => `<div class="flex justify-between items-center text-sm"><div class="flex items-center"><span class="truncate pr-2 cursor-pointer edit-vt-usage-trigger" data-vt-usage-edit-id="${u.id}">${u.description || 'Despesa VT'}</span></div><div class="flex items-center"><span class="font-medium mr-2">${formatCurrency(Number(u.amount)||0)}</span><button data-vt-usage-edit-id="${u.id}" class="ml-1 text-gray-600 edit-vt-usage-btn" title="Editar"><span class="material-symbols-outlined">edit</span></button><button data-vt-usage-id="${u.id}" class="ml-3 text-red-600 delete-vt-usage-btn" title="Excluir"><span class="material-symbols-outlined">delete</span></button></div></div>`).join('')}</div>`;
                                        })() : '<div class="text-sm text-gray-500 mt-1">Nenhuma compra registrada.</div>'}
                                    </div>
                                </div>
                            </div>`;
                    }
            // Attach handler to add VR usage from the VR card (open transaction modal with payment=VR)
                try {
                    const addVrBtn = container.querySelector('#add-vr-usage-btn');
                    if (addVrBtn) addVrBtn.addEventListener('click', (ev) => {
                        // Open transaction modal for expense and deterministically prefill payment=VR and focus description
                        openModal('expenses', null, { payment: 'VR', focusDescription: true });
                    });
                } catch(e) { console.error('attach add-vr-usage handler', e); }
            container.querySelectorAll('.pay-invoice-btn').forEach(btn => btn.addEventListener('click', (e) => payCardInvoice(e.target.dataset.cardName)));
            // Attach '+' handlers: open transaction modal prefilled with card payment and last used category (if any)
            container.querySelectorAll('.add-card-expense-btn').forEach(btn => btn.addEventListener('click', (e) => {
                const cardName = e.currentTarget.dataset.cardName || e.target.dataset.cardName;
                const prefill = { payment: cardName, focusDescription: true };
                try {
                    if (ui.lastTransactionDefaults && ui.lastTransactionDefaults.category) prefill.category = ui.lastTransactionDefaults.category;
                } catch(e) { /* ignore */ }
                showToast(`Criando despesa para ${cardName}...`, 'bg-blue-600');
                openModal('expenses', null, prefill);
            }));
            // Attach per-item delete and edit buttons for VR usages
            try {
                container.querySelectorAll('.delete-vr-usage-btn').forEach(btn => btn.addEventListener('click', async (ev) => {
                    const id = ev.currentTarget.getAttribute('data-vr-usage-id');
                    if (!id) return;
                    if (!confirm('Excluir este uso de VR?')) return;
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vrUsage)) md.vrUsage = [];
                    const idx = md.vrUsage.findIndex(u => u.id === id);
                    if (idx > -1) md.vrUsage.splice(idx, 1);
                    try { await storage.saveData(state.appData); showToast('Uso de VR excluído.', 'bg-green-600'); } catch(e) { console.error('delete vr usage save', e); showToast('Falha ao salvar exclusão.', 'bg-red-600'); }
                    render();
                }));
                // VT handlers: add, edit, delete
                    try {
                        const addVtBtn = container.querySelector('#add-vt-usage-btn');
                        if (addVtBtn) addVtBtn.addEventListener('click', (ev) => {
                            openModal('expenses', null, { payment: 'VT', focusDescription: true });
                        });
                        container.querySelectorAll('.delete-vt-usage-btn').forEach(btn => btn.addEventListener('click', async (ev) => {
                        const id = ev.currentTarget.getAttribute('data-vt-usage-id');
                        if (!id) return;
                        if (!confirm('Excluir este uso de VT?')) return;
                        const md = getCurrentMonthData();
                        if (!Array.isArray(md.vtUsage)) md.vtUsage = [];
                        const idx = md.vtUsage.findIndex(u => u.id === id);
                        if (idx > -1) md.vtUsage.splice(idx, 1);
                        try { await storage.saveData(state.appData); showToast('Uso de VT excluído.', 'bg-green-600'); } catch(e) { console.error('delete vt usage save', e); showToast('Falha ao salvar exclusão.', 'bg-red-600'); }
                        render();
                    }));
                    container.querySelectorAll('.edit-vt-usage-btn, .edit-vt-usage-trigger').forEach(el => el.addEventListener('click', (ev) => {
                        const id = ev.currentTarget.getAttribute('data-vt-usage-edit-id') || ev.currentTarget.closest('[data-vt-usage-edit-id]')?.getAttribute('data-vt-usage-edit-id');
                        if (!id) return;
                        openVTUsageEdit(id);
                    }));
                } catch(e) { console.error('attach vt usage item handlers', e); }
                // Edit triggers (icon and description clickable)
                container.querySelectorAll('.edit-vr-usage-btn, .edit-vr-usage-trigger').forEach(el => el.addEventListener('click', (ev) => {
                    const id = ev.currentTarget.getAttribute('data-vr-usage-edit-id') || ev.currentTarget.closest('[data-vr-usage-edit-id]')?.getAttribute('data-vr-usage-edit-id');
                    if (!id) return;
                    openVRUsageEdit(id);
                }));
            } catch(e) { console.error('attach vr usage item handlers', e); }
            // VR inline-edit bindings on card amounts
            try {
                container.querySelectorAll('.vr-amount').forEach(el => el.addEventListener('click', (e) => startInlineVREdit(e.currentTarget, e.currentTarget.dataset.vrId)));
            } catch(e) { /* ignore if nothing to bind */ }

            // Attach handlers to last-installment spans inside card lists
            container.querySelectorAll('.last-installment-btn').forEach(el => el.addEventListener('click', (ev) => {
                const financingId = el.dataset.financingId || null;
                const installmentId = el.dataset.installmentId || null;
                goToLastInstallment({ financingId, installmentId });
            }));

            // Show edit icon and remaining total on hover for card expense descriptions
            try {
                container.querySelectorAll('.desc-wrap').forEach(wrap => {
                    wrap.addEventListener('mouseenter', (ev) => {
                        const btn = wrap.querySelector('.edit-cat-btn');
                        const rem = wrap.querySelector('.remaining-total');
                        if (btn) btn.classList.remove('invisible');
                        if (rem) rem.classList.remove('hidden');
                    });
                    wrap.addEventListener('mouseleave', (ev) => {
                        const btn = wrap.querySelector('.edit-cat-btn');
                        const rem = wrap.querySelector('.remaining-total');
                        if (btn) btn.classList.add('invisible');
                        if (rem) rem.classList.add('hidden');
                    });
                });

                // Inline category edit flow: clicking pencil replaces description with select
                container.querySelectorAll('.edit-cat-btn').forEach(btn => btn.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const expId = btn.dataset.expId;
                    if (!expId) return;
                    const md = getCurrentMonthData();
                    const expense = (md.expenses || []).find(e => e.id === expId);
                    if (!expense) return;
                    // Create inline selects: category and type
                    const cats = (state.appData.settings && state.appData.settings.expenseCategories) || [];
                    const select = document.createElement('select');
                    // compact but consistent with modal selects
                    select.className = 'inline-cat-select block w-40 h-8 border border-gray-300 rounded-md shadow-sm text-sm focus:ring-blue-500 focus:border-blue-500';
                    cats.forEach(c => { const o = document.createElement('option'); o.value = c; o.textContent = c; if (c === (expense.category || '')) o.selected = true; select.appendChild(o); });

                    const typeSelect = document.createElement('select');
                    typeSelect.className = 'inline-type-select block w-36 h-8 border border-gray-300 rounded-md shadow-sm text-sm ml-2 focus:ring-blue-500 focus:border-blue-500';
                    const opt1 = document.createElement('option'); opt1.value = 'Essenciais'; opt1.textContent = 'Essencial';
                    const opt2 = document.createElement('option'); opt2.value = 'Não Essenciais'; opt2.textContent = 'Não Essencial';
                    typeSelect.appendChild(opt1); typeSelect.appendChild(opt2);
                    // Preselect current type if present
                    try { if (expense.type && (expense.type === 'Essenciais' || expense.type === 'Não Essenciais')) { typeSelect.value = expense.type; } } catch(e) {}

                    const saveBtn = document.createElement('button'); saveBtn.className = 'ml-2 inline-flex items-center px-2 py-1 bg-green-600 text-white text-xs font-medium rounded'; saveBtn.textContent = 'Salvar';
                    const cancelBtn = document.createElement('button'); cancelBtn.className = 'ml-2 inline-flex items-center px-2 py-1 bg-gray-100 text-gray-700 text-xs font-medium rounded'; cancelBtn.textContent = 'Cancelar';
                    const wrapEl = btn.closest('.desc-wrap');
                    const origText = wrapEl.querySelector('.desc-text');
                    origText.style.display = 'none';
                    // insert category then type select
                    wrapEl.insertBefore(select, btn);
                    wrapEl.insertBefore(typeSelect, btn);
                    wrapEl.insertBefore(saveBtn, btn);
                    wrapEl.insertBefore(cancelBtn, btn);
                    btn.classList.add('invisible');

                    saveBtn.addEventListener('click', async (e) => {
                        const newCat = select.value;
                        const newType = typeSelect.value;
                        expense.category = newCat;
                        expense.type = newType;
                        try { await storage.saveData(state.appData); showToast('Categoria e tipo atualizados', 'bg-green-600'); } catch(err) { console.error('save cat/type', err); showToast('Falha ao salvar alterações', 'bg-red-600'); }
                        // cleanup
                        select.remove(); typeSelect.remove(); saveBtn.remove(); cancelBtn.remove(); btn.classList.remove('invisible'); origText.style.display = ''; render();
                    });
                    cancelBtn.addEventListener('click', (e) => {
                        select.remove(); typeSelect.remove(); saveBtn.remove(); cancelBtn.remove(); btn.classList.remove('invisible'); origText.style.display = '';
                    });
                }));
            } catch(e) { console.error('attach card desc hover/edit handlers', e); }
        }

        function renderInvestmentsView() {
            const allData = Object.values(state.appData.data).flatMap(year => Object.values(year));
            const allSavings = allData.flatMap(month => month.savings || []);
            const totalInvested = allSavings.reduce((sum, s) => sum + s.amount, 0);
            const currentMonthSavings = (getCurrentMonthData().savings || []).reduce((sum, s) => sum + s.amount, 0);
            const monthsWithSavings = allData.filter(m => ((m.savings || []).reduce((s, t) => s + t.amount, 0)) > 0);
            const avgMonthlyInvestment = monthsWithSavings.length > 0 ? totalInvested / monthsWithSavings.length : 0;
            
            document.getElementById('kpi-total-invested').textContent = formatCurrency(totalInvested);
            document.getElementById('kpi-monthly-investment').textContent = formatCurrency(currentMonthSavings);
            document.getElementById('kpi-avg-monthly-investment').textContent = formatCurrency(avgMonthlyInvestment);

            const futureValue = (pv, pmt, rate, periods) => {
                let fv = pv;
                for (let i = 0; i < periods; i++) { fv = (fv + pmt) * (1 + rate); }
                return fv;
            };
            const monthlyRate = (1 + 0.08)**(1/12) - 1;

            document.getElementById('projection-1y').textContent = formatCurrency(futureValue(totalInvested, avgMonthlyInvestment, monthlyRate, 12));
            document.getElementById('projection-5y').textContent = formatCurrency(futureValue(totalInvested, avgMonthlyInvestment, monthlyRate, 60));
            document.getElementById('projection-10y').textContent = formatCurrency(futureValue(totalInvested, avgMonthlyInvestment, monthlyRate, 120));
            
            renderGoals();
            renderMonthlySavingsChart();
            renderPortfolioCompositionChart();
        }

        // Simple handler for paying a card invoice (placeholder)
        async function payCardInvoice(cardName) {
            try {
                if (!cardName) return;
                // Marca todas as despesas deste mês com payment === cardName como pagas
                const monthData = getCurrentMonthData();
                (monthData.expenses || []).forEach(exp => { if (exp.payment === cardName) exp.isPaid = true; });
                try {
                    await storage.saveData(state.appData);
                    showToast(`Fatura ${cardName} marcada como paga neste mês.`, 'bg-green-600');
                } catch (e) {
                    console.error('Erro ao salvar status da fatura:', e);
                    showToast('Falha ao salvar status da fatura no Firebase.', 'bg-red-600');
                }
                render();
            } catch (e) { console.error('payCardInvoice', e); }
        }

        async function deleteGoal(id) {
            if (!id) return;
            if (!confirm('Tem certeza que deseja excluir esta meta?')) return;
            const idx = (state.appData.settings.goals || []).findIndex(g => g.id === id);
            if (idx > -1) {
                state.appData.settings.goals.splice(idx, 1);
                try {
                    await storage.saveData(state.appData);
                    showToast('Meta excluída', 'bg-red-600');
                } catch (e) {
                    console.error('Erro ao excluir meta:', e);
                    showToast('Falha ao excluir meta no Firebase.', 'bg-red-600');
                }
                renderInvestmentsView();
            }
        }

        function renderPortfolioCompositionChart() {
            try {
                destroyChart('portfolio-composition-chart');
                const allSavings = Object.values(state.appData.data).flatMap(y => Object.values(y)).flatMap(m => m.savings || []);
                const portfolio = allSavings.reduce((acc, s) => { acc[s.category] = (acc[s.category]||0) + (s.amount||0); return acc; }, {});
                const ctx = document.getElementById('portfolio-composition-chart'); if (!ctx) return;
                ui.charts['portfolio-composition-chart'] = new Chart(ctx.getContext('2d'), { type:'doughnut', data:{ labels:Object.keys(portfolio), datasets:[{ data:Object.values(portfolio), backgroundColor:['#059669','#EA580C','#65A30D','#C026D3','#2563EB','#E11D48'] }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}} });
            } catch(e){console.error('renderPortfolioCompositionChart', e)}
        }

        /**
         * Retorna o número de dias úteis (segunda a sexta) de um mês específico.
         * year - ano (ex: 2025)
         * month - mês 1-12
         */
        function diasUteisNoMes(year, month) {
            // month 1-12
            const m = month - 1;
            const primeiro = new Date(year, m, 1);
            const ultimo = new Date(year, m + 1, 0);
            let diasUteis = 0;
            for (let d = 1; d <= ultimo.getDate(); d++) {
                const dt = new Date(year, m, d);
                const dia = dt.getDay(); // 0 domingo, 6 sabado
                if (dia !== 0 && dia !== 6) diasUteis++;
            }
            return diasUteis;
        }

        /**
         * calcularSalarioLiquido(params)
         * Calcula salário líquido e detalhamento conforme regras fornecidas (INSS/IRRF 2025).
         * Parâmetro params (obj):
         *  - salarioBase (number)
         *  - percentualPericulosidade (number) - ex: 30
         *  - outrosProventosTributaveis (number) - default 0
         *  - numeroDependentes (int) - default 0
         *  - valorDesjejumDia (number) - default 0
         *  - valorTransporteDia (number) - default 0
         *  - diasTrabalhados (int) - default 22 (pode ser calculado por year/month)
         *  - horasExtrasSabado (number horas) - default 0
         *  - horasExtrasDomingo (number horas) - default 0
         *  - jornadaMensalHoras (number) - default 220
         *  - hourlyRate (number) - valor por hora, opcional
         *  - hoursWorked (number) - horas trabalhadas no mês, opcional
         *  - year, month (opcionais) para calcular dias úteis automaticamente
         * Retorna objeto JSON com resumo e detalhamento.
         */
        function calcularSalarioLiquido(params = {}) {
            const p = Object.assign({
                salarioBase: 0,
                percentualPericulosidade: 0,
                outrosProventosTributaveis: 0,
                numeroDependentes: 0,
                valorDesjejumDia: 0,
                valorTransporteDia: 0,
                diasTrabalhados: undefined,
                horasExtrasSabado: 0,
                horasExtrasDomingo: 0,
                jornadaMensalHoras: 220,
                // hourlyRate/hoursWorked removed - valorHora will be derived from salarioBase / jornadaMensalHoras or salary-horas-trabalhadas input
                year: undefined,
                month: undefined
            }, params);

            // If hoursWorked provided explicitly, use it; otherwise default to jornadaMensalHoras
            if (!p.hoursTrabalhadas || p.hoursTrabalhadas === 0) {
                // allow external callers to pass hoursTrabalhadas into params; default to jornadaMensalHoras
                p.hoursTrabalhadas = p.jornadaMensalHoras;
            }
            // Dias trabalhados padrão: dias úteis do mês (quando year/month fornecidos).
            // Se o usuário forneceu 'hoursTrabalhadas', derivamos dias trabalhados a partir da jornada mensal e dias úteis.
            const baseDiasUteis = (p.year && p.month) ? diasUteisNoMes(p.year, p.month) : 22;
            if ((typeof p.diasTrabalhados === 'undefined' || p.diasTrabalhados === null) && p.hoursTrabalhadas && p.hoursTrabalhadas > 0) {
                // hora por dia = jornadaMensalHoras / baseDiasUteis
                const horasPorDia = p.jornadaMensalHoras > 0 ? (p.jornadaMensalHoras / baseDiasUteis) : 8;
                p.diasTrabalhados = Math.round(p.hoursTrabalhadas / horasPorDia);
            }
            if ((typeof p.diasTrabalhados === 'undefined' || p.diasTrabalhados === null) && p.year && p.month) {
                p.diasTrabalhados = baseDiasUteis;
            }
            // Fallback padrão
            if (typeof p.diasTrabalhados === 'undefined' || p.diasTrabalhados === null) p.diasTrabalhados = 22;

            // Constantes 2025
            const INSS_BRACKETS = [
                { upTo: 1518.00, rate: 0.075 },
                { upTo: 2793.88, rate: 0.09 },
                { upTo: 4190.83, rate: 0.12 },
                { upTo: 8157.41, rate: 0.14 }
            ];
            const IRRF_BRACKETS = [
                { upTo: 2428.80, rate: 0.0, deduction: 0.00 },
                { upTo: 2826.65, rate: 0.075, deduction: 182.16 },
                { upTo: 3751.05, rate: 0.15, deduction: 394.16 },
                { upTo: 4664.68, rate: 0.225, deduction: 675.49 },
                { upTo: Infinity, rate: 0.275, deduction: 908.73 }
            ];
            const DEPENDENT_DEDUCTION = 189.59;

            // 1) Salário bruto tributável
            // If the employee worked fewer days/hours than the full month, prorate salárioBase and periculosidade
            const fullMonthDias = (p.year && p.month) ? diasUteisNoMes(p.year, p.month) : 22;
            const diasWorked = (typeof p.diasTrabalhados !== 'undefined' && p.diasTrabalhados !== null) ? p.diasTrabalhados : fullMonthDias;
            const proporcao = (fullMonthDias > 0) ? Math.min(1, diasWorked / fullMonthDias) : 1;
            // Also consider horas trabalhadas if provided: derive proportion from hours as well and use the smaller proportion
            let proporcaoHoras = 1;
            if (p.hoursTrabalhadas && p.hoursTrabalhadas > 0) {
                proporcaoHoras = Math.min(1, p.hoursTrabalhadas / p.jornadaMensalHoras);
            }
            const finalProporcao = Math.min(proporcao, proporcaoHoras);

            const salarioBaseProrata = p.salarioBase * finalProporcao;
            const adicionalPericulosidade = (salarioBaseProrata * (p.percentualPericulosidade || 0)) / 100;
            const brutoTributavelSemExtras = salarioBaseProrata + adicionalPericulosidade + (p.outrosProventosTributaveis || 0);

            // 2) Horas extras: calcular valor hora com base na jornada mensal (valorHora = salarioBase / jornadaMensalHoras)
            const valorHora = (p.jornadaMensalHoras > 0) ? (p.salarioBase / p.jornadaMensalHoras) : ((p.hoursTrabalhadas && p.hoursTrabalhadas > 0) ? (p.salarioBase / p.hoursTrabalhadas) : 0);
            // Sábado 50% (ou seja, 1.5 * hora normal), Domingo 100% (2.0 * hora normal)
            const valorHorasExtras = (p.horasExtrasSabado || 0) * (valorHora * 1.5) + (p.horasExtrasDomingo || 0) * (valorHora * 2.0);

            const salarioBrutoTributavel = brutoTributavelSemExtras + valorHorasExtras;

            // 3) Cálculo do INSS progressivo
            let remaining = salarioBrutoTributavel;
            let inssTotal = 0;
            const inssPorFaixa = [];
            let lower = 0;
            for (let i = 0; i < INSS_BRACKETS.length; i++) {
                const faixa = INSS_BRACKETS[i];
                const upper = faixa.upTo;
                const taxable = Math.max(0, Math.min(remaining, upper - lower));
                const desconto = taxable * faixa.rate;
                inssPorFaixa.push({ lower: lower + 0.01, upper, taxable: round(taxable), rate: faixa.rate, desconto: round(desconto) });
                inssTotal += desconto;
                remaining -= taxable;
                lower = upper;
                if (remaining <= 0) break;
            }
            inssTotal = round(inssTotal);

            // 4) Base de cálculo IRRF
            const totalDependenteDeduction = (p.numeroDependentes || 0) * DEPENDENT_DEDUCTION;
            const baseIRRF = Math.max(0, salarioBrutoTributavel - inssTotal - totalDependenteDeduction);

            // 5) Cálculo IRRF
            let irrfRate = 0, irrfDeduction = 0, irrfValue = 0;
            for (let i = 0; i < IRRF_BRACKETS.length; i++) {
                const b = IRRF_BRACKETS[i];
                if (baseIRRF <= b.upTo) {
                    irrfRate = b.rate;
                    irrfDeduction = b.deduction;
                    break;
                }
            }
            irrfValue = round(Math.max(0, baseIRRF * irrfRate - irrfDeduction));

            // 6) Salário líquido
            const totalDescontos = round(inssTotal + irrfValue);
            const salarioLiquido = round(salarioBrutoTributavel - totalDescontos);

            // 7) Benefícios não tributáveis (por dia trabalhado)
            const beneficiosTotais = round(((p.valorDesjejumDia || 0) + (p.valorTransporteDia || 0)) * (p.diasTrabalhados || 0));

            // 8) Remuneração total mensal
            const remuneracaoTotal = round(salarioLiquido + beneficiosTotais);

            // 9) FGTS (8% sobre o bruto tributável) - encargo do empregador
            const fgts = round(0.08 * salarioBrutoTributavel);

            // Monta retorno detalhado
            const result = {
                resumo: {
                    salarioBase: formatNumber(p.salarioBase),
                    adicionalPericulosidade: formatNumber(adicionalPericulosidade),
                    valorHorasExtras: formatNumber(valorHorasExtras),
                    salarioBrutoTributavel: formatNumber(salarioBrutoTributavel),
                    totalDescontos: formatNumber(totalDescontos),
                    salarioLiquido: formatNumber(salarioLiquido),
                    beneficiosTotais: formatNumber(beneficiosTotais),
                    remuneracaoTotal: formatNumber(remuneracaoTotal),
                    fgts: formatNumber(fgts)
                },
                detalhe: {
                    proventos: {
                        salarioBase: formatNumber(p.salarioBase),
                        adicionalPericulosidade: formatNumber(adicionalPericulosidade),
                        outrosProventosTributaveis: formatNumber(p.outrosProventosTributaveis || 0),
                        valorHorasExtras: formatNumber(valorHorasExtras)
                    },
                    descontos: {
                        inssPorFaixa,
                        inssTotal: formatNumber(inssTotal),
                        baseIRRF: formatNumber(baseIRRF),
                        irrfRate,
                        irrfDeduction: formatNumber(irrfDeduction),
                        irrfValue: formatNumber(irrfValue)
                    },
                    beneficios: {
                        valorDesjejumDia: formatNumber(p.valorDesjejumDia || 0),
                        valorTransporteDia: formatNumber(p.valorTransporteDia || 0),
                        diasTrabalhados: p.diasTrabalhados,
                        beneficiosTotais: formatNumber(beneficiosTotais)
                    },
                    encargos: {
                        fgts: formatNumber(fgts)
                    }
                }
            };

            return result;

            // helpers
            function round(v) { return Math.round((v + Number.EPSILON) * 100) / 100; }
            function formatNumber(v) { return (typeof v === 'number') ? v.toFixed(2) : Number(v || 0).toFixed(2); }
        }

        function renderAllTables() {
            renderIncomeTable();
            renderExpenseTable();
            renderSavingsTable();
        }

        function renderIncomeTable() {
            // Inicializa array de entradas para evitar erro
            const monthData = getCurrentMonthData();
            if (!Array.isArray(monthData.incomes)) monthData.incomes = [];
            if (!Array.isArray(monthData.vrLedger)) monthData.vrLedger = [];
            if (!Array.isArray(monthData.vrUsage)) monthData.vrUsage = [];
            const incomes = monthData.incomes;
            ui.incomeTableBody.innerHTML = '';
            if (incomes.length > 0) {
                // Exclude benefit entries (VR/VT) from the standard incomes list; they are shown as ledger rows below
                incomes.filter(i => (i.source || '').toString() !== 'benefit-vr' && (i.source || '').toString() !== 'benefit-vt').forEach(income => renderIncomeRow(income));
            } else {
                ui.incomeTableBody.innerHTML = '<tr><td colspan="3" class="text-center text-gray-500 py-4">Nenhuma entrada registrada.</td></tr>';
            }
            // Render benefit ledgers (VR and VT) in a generic way so Entradas shows them consistently
            try {
                function renderBenefitLedgerRows(type) {
                    const md = monthData;
                    const keyLedger = (type === 'vt') ? 'vtLedger' : 'vrLedger';
                    const ledger = Array.isArray(md[keyLedger]) ? md[keyLedger] : [];
                    ledger.forEach(l => {
                        const r = ui.incomeTableBody.insertRow();
                        r.dataset[`${type}Id`] = l.id || '';
                        // colorize row by type: VR = green, VT = yellow
                        const baseClass = (type === 'vt') ? 'border-b border-gray-100 bg-yellow-50 text-yellow-700' : 'border-b border-gray-100 bg-green-50 text-green-700';
                        r.className = baseClass + ' animate-fade-in';
                        const descDefault = (type === 'vt') ? 'Benefício - VT' : 'Benefício - VR';
                        const recurringIcon = l.isRecurring ? '<span class="material-symbols-outlined text-xs text-gray-400" title="Recorrente">autorenew</span>' : '';
                        const amountSpan = (type === 'vt') ? `<span class="vt-amount" data-vt-id="${l.id}">${formatCurrency(l.amount || 0)}</span>` : `<span class="vr-amount" data-vr-id="${l.id}">${formatCurrency(l.amount || 0)}</span>`;
                        const editBtn = (type === 'vt') ? `<button class="edit-vt-btn p-1 text-gray-500 hover:text-blue-600" data-vt-id="${l.id}"><span class="material-symbols-outlined text-xl">edit</span></button>` : `<button class="edit-vr-btn p-1 text-gray-500 hover:text-blue-600" data-vr-id="${l.id}"><span class="material-symbols-outlined text-xl">edit</span></button>`;
                        const deleteBtn = (type === 'vt') ? `<button class="delete-vt-btn p-1 text-gray-500 hover:text-red-600" data-vt-id="${l.id}"><span class="material-symbols-outlined text-xl">delete</span></button>` : `<button class="delete-vr-btn p-1 text-gray-500 hover:text-red-600" data-vr-id="${l.id}"><span class="material-symbols-outlined text-xl">delete</span></button>`;
                        r.innerHTML = `
                            <td class="py-2 px-3">${l.description || descDefault} ${recurringIcon}</td>
                            <td class="py-2 px-3 font-medium">${amountSpan}</td>
                            <td class="py-2 px-3 text-right actions-cell">${editBtn}${deleteBtn}</td>`;
                    });
                }
                // Render VR and VT ledger rows
                renderBenefitLedgerRows('vr');
                renderBenefitLedgerRows('vt');

                // attach inline edit handlers for amounts and edit/delete actions for VR and VT
                ui.incomeTableBody.querySelectorAll('.vr-amount').forEach(el => el.addEventListener('click', (e) => startInlineVREdit(e.currentTarget, e.currentTarget.dataset.vrId)));
                ui.incomeTableBody.querySelectorAll('.edit-vr-btn').forEach(b => b.addEventListener('click', (e) => { const id = e.currentTarget.dataset.vrId; openVREdit(id); }));
                ui.incomeTableBody.querySelectorAll('.delete-vr-btn').forEach(b => b.addEventListener('click', async (e) => {
                    const id = e.currentTarget.dataset.vrId;
                    if (!id) return;
                    const md = getCurrentMonthData();
                    const entry = (md.vrLedger || []).find(v => v.id === id) || null;
                    if (!entry) return;
                    if (entry.isRecurring && entry.recurringId) {
                        const delAll = confirm('Este benefício é recorrente. Deseja excluir este e todas as recorrências futuras? (OK = Sim)');
                        if (!delAll) return;
                        await deleteVRLedgerEntry(id);
                        render();
                    } else {
                        if (confirm('Excluir lançamento de VR?')) { await deleteVRLedgerEntry(id); render(); }
                    }
                }));
                // VT handlers
                ui.incomeTableBody.querySelectorAll('.vt-amount').forEach(el => el.addEventListener('click', (e) => startInlineVTEdit && typeof startInlineVTEdit === 'function' ? startInlineVTEdit(e.currentTarget, e.currentTarget.dataset.vtId) : null));
                ui.incomeTableBody.querySelectorAll('.edit-vt-btn').forEach(b => b.addEventListener('click', (e) => { const id = e.currentTarget.dataset.vtId; openVTEdit(id); }));
                ui.incomeTableBody.querySelectorAll('.delete-vt-btn').forEach(b => b.addEventListener('click', async (e) => {
                    const id = e.currentTarget.dataset.vtId;
                    if (!id) return;
                    const md = getCurrentMonthData();
                    const entry = (md.vtLedger || []).find(v => v.id === id) || null;
                    if (!entry) return;
                    if (entry.isRecurring && entry.recurringId) {
                        const delAll = confirm('Este benefício é recorrente. Deseja excluir este e todas as recorrências futuras? (OK = Sim)');
                        if (!delAll) return;
                        await deleteVTLedgerEntry(id);
                        render();
                    } else {
                        if (confirm('Excluir lançamento de VT?')) { await deleteVTLedgerEntry(id); render(); }
                    }
                }));
            } catch(e) { console.error('renderIncomeTable benefit rows', e); }
        }

        function getMonthVRBalance(monthData) {
            if (!monthData) monthData = getCurrentMonthData();
            const ledger = Array.isArray(monthData.vrLedger) ? monthData.vrLedger : [];
            const usage = Array.isArray(monthData.vrUsage) ? monthData.vrUsage : [];
            // Ensure numeric conversion (some entries may contain strings)
            const sumLedger = ledger.reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
            const sumUsage = usage.reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
            // Round to 2 decimals
            const bal = Math.round((sumLedger - sumUsage + Number.EPSILON) * 100) / 100;
            return Math.max(0, bal);
        }

        // VT balance helper (mirror VR)
        function getMonthVTBalance(monthData) {
            if (!monthData) monthData = getCurrentMonthData();
            const ledger = Array.isArray(monthData.vtLedger) ? monthData.vtLedger : [];
            const usage = Array.isArray(monthData.vtUsage) ? monthData.vtUsage : [];
            const sumLedger = ledger.reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
            const sumUsage = usage.reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
            const bal = Math.round((sumLedger - sumUsage + Number.EPSILON) * 100) / 100;
            return Math.max(0, bal);
        }

        // Utility: sort array of strings alphabetically (case-insensitive)
        function sortStrings(arr) {
            if (!Array.isArray(arr)) return [];
            return arr.slice().sort((a,b) => {
                const sa = (a||'').toString().toLowerCase();
                const sb = (b||'').toString().toLowerCase();
                return sa < sb ? -1 : sa > sb ? 1 : 0;
            });
        }

        function renderExpenseTable() {
            // Inicializa array de despesas para evitar erro
            let expenses = Array.isArray(getCurrentMonthData().expenses) ? [...getCurrentMonthData().expenses] : [];
            if (state.filters.searchTerm) {
                expenses = expenses.filter(exp => exp.description.toLowerCase().includes(state.filters.searchTerm.toLowerCase()));
            }
            // Apply advanced expense filters if present
            const ef = state.filters.expenseFilters || {};
            if (ef) {
                if (ef.payment) expenses = expenses.filter(exp => (exp.payment || '') === ef.payment);
                if (ef.category) expenses = expenses.filter(exp => (exp.category || '') === ef.category);
                if (ef.type) {
                    if (ef.type === 'expense') expenses = expenses.filter(exp => !exp.isSaving);
                    if (ef.type === 'saving') expenses = expenses.filter(exp => exp.isSaving);
                }
                if (ef.recurring) expenses = expenses.filter(exp => !!exp.isRecurring);
                if (ef.installment) expenses = expenses.filter(exp => !!exp.installmentId || !!exp.financingId || !!exp.totalInstallments || !!exp.totalFinancing);
                // Spending type filter: essencial / nao-essencial / reserva
                if (ef.spendingType) {
                    const settings = state.appData && state.appData.settings ? state.appData.settings : {};
                    // If the app has a custom categoryGroups mapping, use it. Expected shape: { essencial: ['Contas', ...], naoEssencial: [...], reserva: [...] }
                    const groups = settings.categoryGroups || {};
                    let essencials = groups.essencial || groups.essenciais || [];
                    let naoEssenciais = groups.naoEssencial || groups.naoEssenciais || [];
                    let reservas = groups.reserva || groups.reservas || [];
                    // Fallback sensible defaults when no mapping provided
                    if (!essencials || essencials.length === 0) {
                        essencials = ['Contas','Mercado','Saúde','Transporte','Assinaturas'];
                    }
                    if (!reservas || reservas.length === 0) {
                        reservas = settings.savingCategories || ['Reserva de Emergência','Poupança'];
                    }
                    if (ef.spendingType === 'essencial') {
                        expenses = expenses.filter(exp => essencials.includes(exp.category));
                    } else if (ef.spendingType === 'nao-essencial') {
                        expenses = expenses.filter(exp => !essencials.includes(exp.category) && !reservas.includes(exp.category));
                    } else if (ef.spendingType === 'reserva') {
                        expenses = expenses.filter(exp => reservas.includes(exp.category));
                    }
                }
            }
            expenses.sort((a, b) => {
                const key = state.sort.key;
                const order = state.sort.order === 'asc' ? 1 : -1;
                if (key === 'amount') return (a.amount - b.amount) * order;
                const valA = a[key] || '';
                const valB = b[key] || '';
                return valA.localeCompare(valB) * order;
            });
            ui.expensesTableBody.innerHTML = '';
            if (expenses.length > 0) {
                expenses.forEach(expense => renderExpenseRow(expense));
            } else {
                ui.expensesTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500 py-4">Nenhuma despesa registrada.</td></tr>';
            }
            updateSortHeaders();
        }

        function renderSavingsTable() {
            // Inicializa array de reservas para evitar erro
            const savings = Array.isArray(getCurrentMonthData().savings) ? getCurrentMonthData().savings : [];
            ui.savingsTableBody.innerHTML = '';
            if(savings.length > 0) {
                savings.forEach(saving => renderSavingRow(saving));
            } else {
                ui.savingsTableBody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-500 py-4">Nenhuma reserva registrada.</td></tr>';
            }
        }

        function renderIncomeRow(income) {
            const row = ui.incomeTableBody.insertRow();
            row.dataset.id = income.id;
            row.className = 'border-b border-gray-200 hover:bg-gray-50 animate-fade-in';
            row.innerHTML = `
                <td class="py-3 px-3" data-label="Descrição">${income.description} ${income.isRecurring ? '<span class="material-symbols-outlined text-xs text-gray-400" title="Recorrente">autorenew</span>' : ''}</td>
                <td class="py-3 px-3 text-green-600 font-medium" data-label="Valor">${formatCurrency(income.amount)}</td>
                <td class="py-3 px-3 text-right actions-cell">
                    <button class="edit-btn p-1 text-gray-500 hover:text-blue-600" title="Editar"><span class="material-symbols-outlined text-xl">edit</span></button>
                    <button class="delete-btn p-1 text-gray-500 hover:text-red-600" title="Excluir"><span class="material-symbols-outlined text-xl">delete</span></button>
                </td>`;
        }

        function renderExpenseRow(expense) {
            const row = ui.expensesTableBody.insertRow();
            row.dataset.id = expense.id;
            row.className = `border-b border-gray-200 hover:bg-gray-50 animate-fade-in ${expense.isPaid ? 'opacity-60' : ''}`;
            // Build the installments/financing display with a clickable total that jumps to last installment
            // Use a plain span for the clickable area so it inherits all typography and spacing
            const installmentHtml = expense.totalInstallments ? `<span class="text-xs text-gray-500">(${expense.currentInstallment}/<span class="last-installment-btn" data-installment-id="${expense.installmentId}" data-total="${expense.totalInstallments}">${expense.totalInstallments}</span>)</span>` : '';
            const financingHtml = (expense.financingId && expense.totalFinancing) ? `<span class="text-xs text-gray-500">(${expense.currentFinancing}/<span class="last-installment-btn" data-financing-id="${expense.financingId}" data-total="${expense.totalFinancing}">${expense.totalFinancing}</span>)</span>` : '';

            row.innerHTML = `
                <td class="py-3 px-3 checkbox-cell" data-label="Pago"><input type="checkbox" class="paid-checkbox h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer" ${expense.isPaid ? 'checked' : ''}></td>
                <td class="py-3 px-3" data-label="Descrição">${expense.description} ${expense.isRecurring ? '<span class="material-symbols-outlined text-xs text-gray-400" title="Recorrente">autorenew</span>' : ''} ${installmentHtml} ${financingHtml}</td>

                <td class="py-3 px-3 text-gray-600" data-label="Pagamento">${expense.payment}</td>
                <td class="py-3 px-3 text-gray-600" data-label="Categoria">${expense.category}</td>
                <td class="py-3 px-3 text-red-600 font-medium" data-label="Valor">${formatCurrency(expense.amount)}</td>
                <td class="py-3 px-3 text-right actions-cell">
                    <button class="edit-btn p-1 text-gray-500 hover:text-blue-600 disabled:opacity-30 disabled:cursor-not-allowed" title="Editar" ${expense.installmentId ? 'disabled' : ''}><span class="material-symbols-outlined text-xl">${expense.installmentId ? 'lock' : 'edit'}</span></button>
                    <button class="delete-btn p-1 text-gray-500 hover:text-red-600" title="Excluir"><span class="material-symbols-outlined text-xl">delete</span></button>
                </td>`;

            // Attach click handler to jump to last installment when present (span will be visually identical)
            const lastBtn = row.querySelector('.last-installment-btn');
            if (lastBtn) {
                lastBtn.addEventListener('click', (ev) => {
                    const financingId = lastBtn.dataset.financingId || null;
                    const installmentId = lastBtn.dataset.installmentId || null;
                    goToLastInstallment({ financingId, installmentId });
                });
            }
        }

        function renderSavingRow(saving) {
            const row = ui.savingsTableBody.insertRow();
            row.dataset.id = saving.id;
            row.className = 'border-b border-gray-200 hover:bg-gray-50 animate-fade-in';
            row.innerHTML = `
                <td class="py-3 px-3" data-label="Descrição">${saving.description} ${saving.isRecurring ? '<span class="material-symbols-outlined text-xs text-gray-400" title="Recorrente">autorenew</span>' : ''}</td>
                <td class="py-3 px-3 text-gray-600" data-label="Categoria">${(state.appData.settings.goals||[]).some(g=>g.name===saving.category) ? 'Meta' : saving.category}</td>
                <td class="py-3 px-3 font-medium text-indigo-600" data-label="Valor">${formatCurrency(saving.amount)}</td>
                <td class="py-3 px-3 text-right actions-cell">
                    <button class="edit-btn p-1 text-gray-500 hover:text-blue-600" title="Editar"><span class="material-symbols-outlined text-xl">edit</span></button>
                    <button class="delete-btn p-1 text-gray-500 hover:text-red-600" title="Excluir"><span class="material-symbols-outlined text-xl">delete</span></button>
                </td>`;
        }

        function renderGoals() {
            const container = ui.goalsContainer;
            const goals = (state.appData.settings.goals || []).slice().sort((a,b) => { const A=(a.name||'').toLowerCase(); const B=(b.name||'').toLowerCase(); return A < B ? -1 : A > B ? 1 : 0; });
            const allSavings = Object.values(state.appData.data).flatMap(y => Object.values(y)).flatMap(m => m.savings || []);
            
            container.innerHTML = goals.length === 0 ? '<p class="text-center text-gray-500">Nenhuma meta definida.</p>' : '';

            goals.forEach(goal => {
                const totalSavedForGoal = allSavings.filter(s => s.category === goal.name).reduce((sum, s) => sum + s.amount, 0);
                const percentage = Math.min((totalSavedForGoal / goal.amount) * 100, 100);
                const isCompleted = percentage >= 100;
                if (isCompleted) {
                    showToast(`Meta atingida: ${goal.name}! Parabéns!`, 'bg-green-600');
                    if (window.confetti) window.confetti();
                }
                container.innerHTML += `
                    <div class="goal-item">
                        <div class="flex justify-between items-center mb-1">
                            <span class="font-semibold">${goal.name} ${isCompleted ? '🎉' : ''}</span>
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-gray-600">${formatCurrency(totalSavedForGoal)} / ${formatCurrency(goal.amount)}</span>
                                <button data-id="${goal.id}" class="delete-goal-btn p-1 text-gray-400 hover:text-red-500"><span class="material-symbols-outlined text-lg">delete</span></button>
                            </div>
                        </div>
                        <div class="progress-bar">
                            <div class="bg-green-500" style="width: ${percentage}%"></div>
                        </div>
                    </div>`;
            });
            container.querySelectorAll('.delete-goal-btn').forEach(btn => btn.addEventListener('click', (e) => deleteGoal(e.currentTarget.dataset.id)));
        }

        // --- KPIs, Feedback and Charts ---
    function updateKPIs() {
            try {
                const monthData = getCurrentMonthData();
                const totalIncome = (monthData.incomes || []).reduce((s, t) => s + (t.amount || 0), 0);
                const totalExpenses = (monthData.expenses || []).filter(t => t.isPaid).reduce((s, t) => s + (t.amount || 0), 0);
                const totalSavings = (monthData.savings || []).reduce((s, t) => s + (t.amount || 0), 0);
                const balance = totalIncome - totalExpenses - totalSavings;

        // Update DOM with animated numbers
        animateKPINumber('kpi-total-income', totalIncome);
        animateKPINumber('kpi-total-expenses', totalExpenses);
        animateKPINumber('kpi-total-savings', totalSavings);
        animateKPINumber('kpi-balance', balance);

                // Projected balance (consider all expenses)
                const totalProjectedExpenses = (monthData.expenses || []).reduce((s, e) => s + (Number(e && e.amount) || 0), 0);
                const projectedBalance = totalIncome - totalProjectedExpenses - totalSavings;
                const projEl = document.getElementById('kpi-projected-balance'); if (projEl) animateKPINumber('kpi-projected-balance', projectedBalance);
                // Populate Despesas Projetadas KPI (shows total of all expenses regardless of paid status)
                const projExpEl = document.getElementById('kpi-projected-expenses'); if (projExpEl) animateKPINumber('kpi-projected-expenses', totalProjectedExpenses);

                // Percentual de cada despesa do mês
                const expenses = monthData.expenses || [];
                const totalMonthExpenses = expenses.reduce((s, exp) => s + (exp.amount || 0), 0);
                const container = document.getElementById('kpi-expense-percentuals');
                if (container) {
                    container.innerHTML = '';
                    if (expenses.length === 0) container.innerHTML = '<span class="text-gray-400 text-xs">Nenhuma despesa registrada.</span>';
                    expenses.forEach(exp => {
                        const percent = totalMonthExpenses > 0 ? ((exp.amount / totalMonthExpenses) * 100).toFixed(1) : '0.0';
                        container.innerHTML += `<div class="flex justify-between text-sm"><span>${exp.description}</span><span>${percent}%</span></div>`;
                    });
                }

                getFeedback(totalIncome, totalExpenses, totalSavings);

                // VR KPI: compute credited and used totals for current month
                try {
                    const creditedTotal = (monthData.vrLedger || []).reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
                    let usedTotal = (monthData.vrUsage || []).reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
                    // include legacy expenses paid with VR (edge-cases)
                    try { const expensesVR = (monthData.expenses || []).filter(e => (e.payment || '') === 'VR'); usedTotal += expensesVR.reduce((s, e) => s + (Number(e && e.amount) || 0), 0); } catch(e) {}
                    const usedRounded = Math.round((usedTotal + Number.EPSILON) * 100) / 100;
                    const creditRounded = Math.round((creditedTotal + Number.EPSILON) * 100) / 100;
                    // displayAmount = available (credited - used) — same shown in Faturas card
                    const displayAmount = Math.max(0, Math.round((creditRounded - usedRounded) * 100) / 100);
                    const valuesEl = document.getElementById('kpi-vr-values'); if (valuesEl) valuesEl.textContent = formatCurrency(displayAmount);
                    const progressEl = document.getElementById('kpi-vr-progress');
                    const barTextEl = document.getElementById('kpi-vr-bar-text');
                    if (progressEl) {
                        const pctRaw = creditRounded > 0 ? (usedRounded / creditRounded) : 0;
                        const pct = Math.min(1, Math.max(0, pctRaw));
                        progressEl.style.width = `${Math.round(pct * 100)}%`;
                        // Color thresholds: green <75%, yellow 75-99%, red >=100%
                        progressEl.classList.remove('bg-green-500','bg-yellow-400','bg-red-500');
                        if (pctRaw >= 1) progressEl.classList.add('bg-red-500');
                        else if (pctRaw >= 0.75) progressEl.classList.add('bg-yellow-400');
                        else progressEl.classList.add('bg-green-500');
                        // tooltip with percent
                        try { progressEl.title = `${Math.round((pctRaw)*100)}% utilizado (${formatCurrency(usedRounded)} de ${formatCurrency(creditRounded)})`; } catch(e){}
                    }
                    if (barTextEl) {
                        // show spent amount centered over the bar with percentage used
                        const pctDisplay = Math.round((creditRounded > 0 ? (usedRounded / creditRounded) : 0) * 100);
                        barTextEl.textContent = `${formatCurrency(usedRounded)} (${pctDisplay}% gasto)`;
                    }
                } catch(e) { console.error('updateKPIs vr kpi', e); }
                // VT KPI: mirror VR logic for VT
                try {
                    const vtCredited = (monthData.vtLedger || []).reduce((s, l) => s + (Number(l && l.amount) || 0), 0);
                    let vtUsed = (monthData.vtUsage || []).reduce((s, u) => s + (Number(u && u.amount) || 0), 0);
                    try { const expensesVT = (monthData.expenses || []).filter(e => (e.payment || '') === 'VT'); vtUsed += expensesVT.reduce((s,e) => s + (Number(e && e.amount) || 0), 0); } catch(e){}
                    const vtUsedRounded = Math.round((vtUsed + Number.EPSILON) * 100) / 100;
                    const vtCreditRounded = Math.round((vtCredited + Number.EPSILON) * 100) / 100;
                    const vtDisplay = Math.max(0, Math.round((vtCreditRounded - vtUsedRounded) * 100) / 100);
                    const vtValuesEl = document.getElementById('kpi-vt-values'); if (vtValuesEl) vtValuesEl.textContent = formatCurrency(vtDisplay);
                    const vtProgressEl = document.getElementById('kpi-vt-progress');
                    const vtBarTextEl = document.getElementById('kpi-vt-bar-text');
                    if (vtProgressEl) {
                        const pctRaw = vtCreditRounded > 0 ? (vtUsedRounded / vtCreditRounded) : 0;
                        const pct = Math.min(1, Math.max(0, pctRaw));
                        vtProgressEl.style.width = `${Math.round(pct * 100)}%`;
                        vtProgressEl.classList.remove('bg-yellow-500','bg-yellow-400','bg-red-500');
                        if (pctRaw >= 1) vtProgressEl.classList.add('bg-red-500');
                        else if (pctRaw >= 0.75) vtProgressEl.classList.add('bg-yellow-500');
                        else vtProgressEl.classList.add('bg-yellow-400');
                        try { vtProgressEl.title = `${Math.round((pctRaw)*100)}% utilizado (${formatCurrency(vtUsedRounded)} de ${formatCurrency(vtCreditRounded)})`; } catch(e){}
                    }
                    if (vtBarTextEl) {
                        const pctDisplayVT = Math.round((vtCreditRounded > 0 ? (vtUsedRounded / vtCreditRounded) : 0) * 100);
                        vtBarTextEl.textContent = `${formatCurrency(vtUsedRounded)} (${pctDisplayVT}% gasto)`;
                    }
                } catch(e) { console.error('updateKPIs vt kpi', e); }
            } catch (e) {
                console.error('updateKPIs error', e);
            }
        }

        function getFeedback(income, expenses, savings) {
            try {
                const settings = state.appData && state.appData.settings ? state.appData.settings : {};
                const feedbackMessages = settings.feedbackMessages || [];
                const spendingGoals = settings.spendingGoals || [];
                let feedbackId = 'B'; // default

                if (income > 0) {
                    const savingGoal = (spendingGoals.find(g => g.type === 'Reserva') || {}).goal || 0;
                    const nonEssentialGoal = (spendingGoals.find(g => g.type === 'Não Essenciais') || {}).goal || 0;
                    const essentialGoal = (spendingGoals.find(g => g.type === 'Essenciais') || {}).goal || 0;

                    if ((income - expenses - savings) < 0) feedbackId = 'F';
                    else if (savings < income * savingGoal) feedbackId = 'E';
                    else if (expenses > income * (nonEssentialGoal + essentialGoal)) feedbackId = 'C';
                    else feedbackId = 'B';
                }

                const msg = (feedbackMessages.find(m => m.id === feedbackId) || {}).text || '';
                if (ui.feedbackMessage) ui.feedbackMessage.textContent = msg;
            } catch (e) {
                console.error('getFeedback error', e);
            }
        }

        function animateKPINumber(id, newValue) {
            const el = document.getElementById(id);
            if (!el) return;
            const last = typeof el._lastValue === 'number' ? el._lastValue : (parseFloat((el.textContent || '0').replace(/[\D]/g, '').replace(',', '.')) || 0);
            const duration = 700;
            const frameRate = 30;
            const steps = Math.max(1, Math.round(duration / (1000 / frameRate)));
            let step = 0;
            const diff = newValue - last;

            // Add animation class
            if (diff > 0) {
                el.classList.add('kpi-animate-up');
            } else if (diff < 0) {
                el.classList.add('kpi-animate-down');
            } else {
                el.classList.add('kpi-animate');
            }

            const animate = () => {
                step++;
                const val = last + diff * (step / steps);
                el.textContent = formatCurrency(val);
                if (step < steps) {
                    setTimeout(animate, 1000 / frameRate);
                } else {
                    el.textContent = formatCurrency(newValue);
                    el._lastValue = newValue;
                    el.classList.remove('kpi-animate');
                    el.classList.remove('kpi-animate-up');
                    el.classList.remove('kpi-animate-down');
                }
            };
            animate();
        }

        function destroyChart(chartId) {
            if (ui.charts && ui.charts[chartId]) {
                try { ui.charts[chartId].destroy(); } catch(e) { /* ignore */ }
                delete ui.charts[chartId];
            }
        }

        function renderCharts() {
            // Defensive: if Chart is not available, skip rendering charts
            if (typeof Chart === 'undefined') return;
            renderSpendingGoalsChart();
            renderCategorySpendingChart();
            renderPaymentMethodChart();
            renderAnnualSummaryChart();
        }

        function renderSpendingGoalsChart() {
            try {
                destroyChart('spending-goals-chart');
                const monthData = getCurrentMonthData();
                const totalIncome = (monthData.incomes || []).reduce((s, t) => s + (t.amount || 0), 0);
                if (totalIncome === 0) return;
                const essentials = (monthData.expenses || []).filter(e => e.type === 'Essenciais').reduce((s,e)=>s+(e.amount||0),0);
                const nonEssentials = (monthData.expenses || []).filter(e => e.type === 'Não Essenciais').reduce((s,e)=>s+(e.amount||0),0);
                const reserve = (monthData.savings || []).reduce((s,e)=>s+(e.amount||0),0);
                const percentages = { 'Essenciais': essentials, 'Não Essenciais': nonEssentials, 'Reserva': reserve };
                const ctx = document.getElementById('spending-goals-chart');
                if (!ctx) return;
                ui.charts['spending-goals-chart'] = new Chart(ctx.getContext('2d'), {
                    type: 'doughnut',
                    data: { labels: Object.keys(percentages), datasets: [{ data: Object.values(percentages), backgroundColor: ['#3B82F6','#F59E0B','#10B981'] }] },
                    options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}} }
                });
            } catch(e){console.error('renderSpendingGoalsChart',e)}
        }

        function renderCategorySpendingChart() {
            try {
                destroyChart('category-spending-chart');
                const monthData = getCurrentMonthData();
                const expenses = monthData.expenses || [];
                const categorySpending = expenses.reduce((acc, exp) => { acc[exp.category] = (acc[exp.category] || 0) + (exp.amount || 0); return acc; }, {});
                const ctx = document.getElementById('category-spending-chart'); if (!ctx) return;
                ui.charts['category-spending-chart'] = new Chart(ctx.getContext('2d'), { type:'pie', data:{ labels:Object.keys(categorySpending), datasets:[{ data:Object.values(categorySpending), backgroundColor:['#EF4444','#F97316','#84CC16','#22C55E','#14B8A6','#06B6D4','#6366F1','#D946EF'] }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}} });
            } catch(e){console.error('renderCategorySpendingChart', e)}
        }

        function renderPaymentMethodChart() {
            try {
                destroyChart('payment-method-chart');
                const monthData = getCurrentMonthData();
                const expenses = monthData.expenses || [];
                const paymentSpending = expenses.reduce((acc, exp) => { acc[exp.payment] = (acc[exp.payment] || 0) + (exp.amount || 0); return acc; }, {});
                const ctx = document.getElementById('payment-method-chart'); if (!ctx) return;
                ui.charts['payment-method-chart'] = new Chart(ctx.getContext('2d'), { type:'pie', data:{ labels:Object.keys(paymentSpending), datasets:[{ data:Object.values(paymentSpending), backgroundColor:['#6D28D9','#BE185D','#047857','#B45309','#1E3A8A'] }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}} });
            } catch(e){console.error('renderPaymentMethodChart', e)}
        }

        function renderAnnualSummaryChart() {
            try {
                destroyChart('annual-summary-chart');
                const yearData = state.appData.data[state.currentDate.getFullYear()] || {};
                const months = Array.from({length:12},(_,i)=>String(i+1).padStart(2,'0'));
                const monthlyTotals = { incomes: [], expenses: [], balance: [] };
                months.forEach(month => {
                    const monthData = yearData[month] || {};
                    const income = (monthData.incomes || []).reduce((s,t)=>s+(t.amount||0),0);
                    const expense = ((monthData.expenses || []).reduce((s,t)=>s+(t.amount||0),0)) + ((monthData.savings || []).reduce((s,t)=>s+(t.amount||0),0));
                    monthlyTotals.incomes.push(income); monthlyTotals.expenses.push(expense); monthlyTotals.balance.push(income-expense);
                });
                const ctx = document.getElementById('annual-summary-chart'); if (!ctx) return;
                ui.charts['annual-summary-chart'] = new Chart(ctx.getContext('2d'), { type:'bar', data:{ labels:['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'], datasets:[ { label:'Entradas', data:monthlyTotals.incomes, backgroundColor:'#22C55E' }, { label:'Saídas', data:monthlyTotals.expenses, backgroundColor:'#EF4444' } ] }, options:{responsive:true, maintainAspectRatio:false, scales:{ x:{ stacked:true }, y:{ stacked:true } } } });
            } catch(e){console.error('renderAnnualSummaryChart', e)}
        }

        // Report-specific charts
        function renderMonthlyReportCategoryChart() {
            try {
                destroyChart('mr-category-breakdown-chart');
                const monthData = getCurrentMonthData();
                const expenses = monthData.expenses || [];
                const byCategory = expenses.reduce((acc, e) => { acc[e.category] = (acc[e.category]||0) + (e.amount||0); return acc; }, {});
                const ctx = document.getElementById('mr-category-breakdown-chart'); if (!ctx || Object.keys(byCategory).length === 0 || typeof Chart === 'undefined') return;
                ui.charts['mr-category-breakdown-chart'] = new Chart(ctx.getContext('2d'), { type:'pie', data:{ labels:Object.keys(byCategory), datasets:[{ data:Object.values(byCategory), backgroundColor:['#EF4444','#F97316','#84CC16','#22C55E','#14B8A6','#06B6D4','#6366F1','#D946EF'] }] }, options:{responsive:true, maintainAspectRatio:false} });
            } catch(e){console.error('renderMonthlyReportCategoryChart', e)}
        }

        function renderAnnualBalanceEvolutionChart() {
            try {
                destroyChart('ar-balance-evolution-chart');
                const year = state.currentDate.getFullYear();
                const yearData = state.appData.data[year] || {};
                const months = Array.from({length:12},(_,i)=>String(i+1).padStart(2,'0'));
                const balances = months.map(m => {
                    const md = yearData[m] || { incomes: [], expenses: [], savings: [] };
                    const inc = (md.incomes || []).reduce((s,t)=>s+(t.amount||0),0);
                    const out = ((md.expenses || []).reduce((s,t)=>s+(t.amount||0),0)) + ((md.savings || []).reduce((s,t)=>s+(t.amount||0),0));
                    return inc - out;
                });
                const ctx = document.getElementById('ar-balance-evolution-chart'); if (!ctx || typeof Chart === 'undefined') return;
                ui.charts['ar-balance-evolution-chart'] = new Chart(ctx.getContext('2d'), { type:'line', data:{ labels:['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'], datasets:[{ label:'Saldo Mensal', data:balances, borderColor:'#2563EB', tension:0.2 }] }, options:{responsive:true, maintainAspectRatio:false} });
            } catch(e){console.error('renderAnnualBalanceEvolutionChart', e)}
        }

        function renderAnnualAvgCategoryChart() {
            try {
                destroyChart('ar-avg-category-spending-chart');
                const year = state.currentDate.getFullYear();
                const yearData = state.appData.data[year] || {};
                // compute average monthly spending per category
                const categories = {};
                const months = Object.keys(yearData);
                months.forEach(m => {
                    const md = yearData[m] || { expenses: [] };
                    (md.expenses || []).forEach(e => { categories[e.category] = (categories[e.category]||0) + (e.amount||0); });
                });
                const avg = {};
                months.forEach(() => {});
                Object.keys(categories).forEach(cat => { avg[cat] = categories[cat] / Math.max(1, months.length); });
                const ctx = document.getElementById('ar-avg-category-spending-chart'); if (!ctx || Object.keys(avg).length === 0 || typeof Chart === 'undefined') return;
                ui.charts['ar-avg-category-spending-chart'] = new Chart(ctx.getContext('2d'), { type:'bar', data:{ labels:Object.keys(avg), datasets:[{ label:'Média Mensal', data:Object.values(avg), backgroundColor:'#F59E0B' }] }, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}} });
            } catch(e){console.error('renderAnnualAvgCategoryChart', e)}
        }

        // end KPIs & charts

        function renderMonthDisplay() {
            ui.currentMonthDisplay.textContent = state.currentDate.toLocaleString('pt-BR', { month: 'long', year: 'numeric' }).replace(/^\w/, c => c.toUpperCase());
        }

        // Month picker helpers
        function populateMonthPicker() {
            try {
                const yearSelect = ui.monthPickerYear;
                if (!yearSelect) return;
                yearSelect.innerHTML = '';
                const currentYear = state.currentDate.getFullYear();
                // show a range of years: currentYear -5 .. currentYear +5
                for (let y = currentYear - 5; y <= currentYear + 5; y++) {
                    const opt = document.createElement('option');
                    opt.value = y;
                    opt.textContent = y;
                    yearSelect.appendChild(opt);
                }
                // set selects to current date
                if (ui.monthPickerMonth) ui.monthPickerMonth.value = String(state.currentDate.getMonth());
                yearSelect.value = String(currentYear);
            } catch (e) { console.error('populateMonthPicker', e); }
        }

        // We'll move the picker to document.body when opened to avoid stacking context issues
        (function(){
            let _originalParent = null;
            let _originalNext = null;
            window.__monthPickerDetached = false;
            function _attachToBody(picker, trigger) {
                if (!picker) return;
                if (!_originalParent) {
                    _originalParent = picker.parentNode;
                    _originalNext = picker.nextSibling;
                }
                document.body.appendChild(picker);
                // On mobile, center the picker fixed to avoid off-screen clipping. On desktop keep absolute aligned to trigger.
                if (window.innerWidth <= 639) {
                    picker.style.position = 'fixed';
                    picker.style.left = '50%';
                    picker.style.top = '18%';
                    picker.style.transform = 'translateX(-50%)';
                    picker.style.width = 'calc(100% - 2rem)';
                    picker.style.maxWidth = '360px';
                    picker.style.right = '';
                } else {
                    picker.style.position = 'absolute';
                    // compute position to align under trigger (right aligned)
                    try {
                        const rect = trigger.getBoundingClientRect();
                        const top = rect.bottom + window.scrollY + 8; // small gap
                        const right = window.innerWidth - (rect.right + window.scrollX);
                        picker.style.top = top + 'px';
                        picker.style.right = right + 'px';
                        picker.style.transform = '';
                    } catch (e) { /* ignore */ }
                }
                window.__monthPickerDetached = true;
            }
            function _restoreParent(picker) {
                if (!picker || !_originalParent) return;
                picker.style.position = '';
                picker.style.top = '';
                picker.style.right = '';
                picker.style.zIndex = '';
                if (_originalNext && _originalNext.parentNode === _originalParent) {
                    _originalParent.insertBefore(picker, _originalNext);
                } else {
                    _originalParent.appendChild(picker);
                }
                _originalParent = null; _originalNext = null; window.__monthPickerDetached = false;
            }

            window.openMonthPicker = function() {
                try {
                    const picker = ui.monthPicker;
                    if (!picker || !ui.currentMonthDisplay) return;
                    populateMonthPicker();
                    _attachToBody(picker, ui.currentMonthDisplay);
                    picker.classList.remove('hidden');
                    setTimeout(() => { if (ui.monthPickerMonth) ui.monthPickerMonth.focus(); }, 50);
                } catch (e) { console.error('openMonthPicker', e); }
            };

            window.closeMonthPicker = function() {
                try {
                    const picker = ui.monthPicker;
                    if (!picker) return;
                    picker.classList.add('hidden');
                    if (window.__monthPickerDetached) _restoreParent(picker);
                } catch (e) { console.error('closeMonthPicker', e); }
            };
        })();

        function closeMonthPicker() {
            try { if (ui.monthPicker) ui.monthPicker.classList.add('hidden'); } catch (e) { console.error('closeMonthPicker', e); }
        }

        function applyMonthPicker() {
            try {
                if (!ui.monthPickerMonth || !ui.monthPickerYear) return;
                const month = parseInt(ui.monthPickerMonth.value, 10);
                const year = parseInt(ui.monthPickerYear.value, 10);
                if (isNaN(month) || isNaN(year)) return;
                state.currentDate = new Date(year, month, 1);
                render();
                closeMonthPicker();
            } catch (e) { console.error('applyMonthPicker', e); }
        }

        function updateSortHeaders() {
            ui.expensesTableHead.querySelectorAll('.sortable-header').forEach(header => {
                const icon = header.querySelector('.sort-icon');
                if (header.dataset.sort === state.sort.key) {
                    header.classList.add('sorted');
                    icon.textContent = state.sort.order === 'asc' ? 'arrow_upward' : 'arrow_downward';
                } else {
                    header.classList.remove('sorted');
                    icon.textContent = '';
                }
            });
        }

        // --- DATA & STATE MANAGEMENT ---

        function goToDate(date) {
            state.currentDate = new Date(date.getFullYear(), date.getMonth(), 1);
            render();
        }

        function changeMonth(direction) {
            state.currentDate.setMonth(state.currentDate.getMonth() + direction);
            render();
               }

        // Jump to the month of the last installment of a financing/installment group
        function goToLastInstallment({ financingId = null, installmentId = null } = {}) {
            try {
                // Collect all matching installments and find the one with the latest date
                let last = null; // { year, month, id }
                // Iterate over state data to find the last installment
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const monthData = state.appData.data[year][month];
                        const expenses = monthData.expenses || [];
                        expenses.forEach(exp => {
                            if (financingId && exp.financingId === financingId) {
                                const candidate = { year: Number(year), month: Number(month) };
                                if (!last || candidate.year > last.year || (candidate.year === last.year && candidate.month > last.month)) {
                                    last = { year: candidate.year, month: candidate.month, id: exp.id };
                                }
                            } else if (installmentId && exp.installmentId === installmentId) {
                                const candidate = { year: Number(year), month: Number(month) };
                                if (!last || candidate.year > last.year || (candidate.year === last.year && candidate.month > last.month)) {
                                    last = { year: candidate.year, month: candidate.month, id: exp.id };
                                }
                            }
                        });
                    });
                });

                if (!last) return; // nothing found

                // Navigate to that month
                const target = new Date(last.year, last.month - 1, 1);
                goToDate(target);
                // After render, highlight the row briefly
                requestAnimationFrame(() => {
                    const row = ui.expensesTableBody.querySelector(`tr[data-id="${last.id}"]`);
                    if (row) {
                        row.classList.add('ring-2', 'ring-blue-300');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-blue-300'), 2000);
                        // Scroll the page to top so the month header is visible
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    }
                });
            } catch (e) {
                console.error('goToLastInstallment error', e);
            }
        }

        function getCurrentMonthData(date = state.currentDate) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            
            // Com a nova `loadData`, state.appData.data sempre existirá.
            // Apenas precisamos garantir que o mês/ano específico exista para evitar erros.
            if (!state.appData.data[year]) {
                state.appData.data[year] = {};
            }
            if (!state.appData.data[year][month]) {
                state.appData.data[year][month] = { incomes: [], expenses: [], savings: [] };
            }
            
            return state.appData.data[year][month];
        }
        
        function handleSort(key) {
            if (state.sort.key === key) {
                state.sort.order = state.sort.order === 'asc' ? 'desc' : 'asc';
            } else {
                state.sort.key = key;
                state.sort.order = 'asc';
            }
            renderExpenseTable();
        }

        function handleTableClick(event, type) {
            const row = event.target.closest('tr');
            if (!row) return;
            const id = row.dataset.id;
            if (event.target.closest('.edit-btn') && !event.target.closest('.edit-btn').disabled) {
                openModal(type, id);
            } else if (event.target.closest('.delete-btn')) {
                deleteTransaction(type, id);
            } else if (event.target.classList.contains('paid-checkbox')) {
                togglePaidStatus(id);
            }
        }

        async function togglePaidStatus(id) {
            const expense = getCurrentMonthData().expenses.find(exp => exp.id === id);
            if (expense) {
                expense.isPaid = !expense.isPaid;
                try {
                    await storage.saveData(state.appData);
                } catch (e) {
                    console.error('Erro ao atualizar status pago:', e);
                    showToast('Falha ao atualizar status no Firebase.', 'bg-red-600');
                }
                render();
            }
        }

        // --- MODALS & UI HELPERS (implementações defensivas) ---
        // openModal now accepts an optional prefill object: { payment, description, amount, focusDescription }
        function openModal(type, id = null, prefill = null) {
            try {
                const modal = ui.transactionModal;
                if (!modal) return;
                // Reset and populate
                if (ui.transactionForm) ui.transactionForm.reset();
                clearTransactionError();
                if (document.getElementById('transaction-id')) document.getElementById('transaction-id').value = '';
                populateDropdowns();
                toggleTransactionType(type || 'expenses');
                // If editing, populate fields
                if (id) {
                    document.getElementById('modal-title').textContent = 'Editar Transação';
                    populateModal(type, id);
                } else {
                    document.getElementById('modal-title').textContent = 'Nova Transação';
                    // Apply session-aware defaults: prefer last used in-session values when present
                    if (!prefill) prepareModalForNextEntry();
                }
                // Show modal
                modal.showModal();

                // Apply optional prefill values deterministically (no timeouts)
                try {
                    if (prefill && typeof prefill === 'object') {
                        const pm = document.getElementById('payment-method');
                        const desc = document.getElementById('description');
                        const cat = document.getElementById('category-expense');

                        if (pm && prefill.payment) {
                            pm.value = prefill.payment;
                            // Dispatch change so existing handlers (which enforce VR/VT rules) run
                            try { pm.dispatchEvent(new Event('change', { bubbles: true })); } catch (e) { try { pm.dispatchEvent(new Event('change')); } catch(e){} }
                        }

                        // If prefill provided a category explicitly, set it
                        if (cat && prefill.category) {
                            try { cat.value = prefill.category; } catch(e){}
                        }

                        // If payment is VT and no explicit description provided, enforce 'Abastecimento'
                        if ((prefill.payment === 'VT') && desc && (prefill.description === undefined || prefill.description === null || prefill.description === '')) {
                            try { desc.value = 'Abastecimento'; } catch(e){}
                        } else if (desc && (prefill.description !== undefined)) {
                            desc.value = prefill.description;
                        }

                        if (prefill.amount !== undefined) {
                            const amt = document.getElementById('amount'); if (amt) amt.value = prefill.amount;
                        }
                        // If requested, focus and select description
                        if (desc && (prefill.focusDescription || prefill.description !== undefined)) {
                            try { desc.focus(); desc.select(); } catch (_) {}
                        }
                    }
                } catch (e) { console.error('openModal apply prefill', e); }

                // Run description detector once to auto-open salary options if description already contains 'salário'
                try {
                    const descInput = document.getElementById('description');
                    if (descInput) {
                        const ev = new Event('input', { bubbles: true });
                        descInput.dispatchEvent(ev);
                    }
                } catch (e) { console.error('openModal run description detector', e); }
            } catch (e) { console.error('openModal', e); }
        }

        function closeModal(modalId) {
            try {
                const el = document.getElementById(modalId);
                if (el && typeof el.close === 'function') el.close();
                // clear any inline error when closing
                clearTransactionError();
                // remove dynamic buttons if present
                const btn = document.getElementById('conclude-financing-btn'); if (btn && btn.parentNode) btn.parentNode.removeChild(btn);
            } catch (e) { console.error('closeModal', e); }
        }

        function populateDropdowns() {
            try {
                const settings = state.appData.settings || {};
                const paymentMethods = settings.paymentMethods || [];
                // If current month has VR balance registered, add a virtual payment method 'VR'
                const md = getCurrentMonthData();
                const vrAmount = md ? getMonthVRBalance(md) : 0;
                // VR as a selectable paymentMethod should be an object with type 'vr'
                const vrOptionObj = { name: 'VR', type: 'vr', available: vrAmount };
                // Merge payments but avoid duplicate VR entries
                const mergedPayments = (paymentMethods || []).slice();
                if (!mergedPayments.find(p => (p && p.name) === 'VR')) mergedPayments.push(vrOptionObj);
                // VT: same approach as VR
                const vtAmount = md ? getMonthVTBalance(md) : 0;
                const vtOptionObj = { name: 'VT', type: 'vt', available: vtAmount };
                if (!mergedPayments.find(p => (p && p.name) === 'VT')) mergedPayments.push(vtOptionObj);
                const expenseCategories = settings.expenseCategories || [];
                const savingCategories = settings.savingCategories || [];
                const goals = settings.goals || [];
                // Ensure Alimentação category exists in settings so it's available in the dropdown
                const normalize = s => (s || '').toString().toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
                const hasAlim = expenseCategories.some(c => normalize(c).includes('aliment'));
                if (!hasAlim) {
                    try {
                        // Add Alimentação to settings and persist once
                        settings.expenseCategories = settings.expenseCategories || [];
                        settings.expenseCategories.push('Alimentação');
                        state.appData.settings = settings;
                        // Save asynchronously but do not block UI
                        storage.saveData(state.appData).then(() => { showToast('Categoria Alimentação adicionada às configurações.', 'bg-green-600'); }).catch(() => {});
                    } catch (e) { console.error('failed to persist alimentação category', e); }
                }
                // Sort lists alphabetically for consistent UX
                const paymentsSorted = sortStrings((mergedPayments || []).map(p => p.name || ''));
                const expenseCatsSorted = sortStrings(expenseCategories || []);
                const savingCatsSorted = sortStrings(savingCategories || []);
                const goalsSorted = sortStrings(goals.map(g => g.name || ''));
                // Build payment method options from mergedPayments so VR is always present
                if (ui.paymentMethod) ui.paymentMethod.innerHTML = paymentsSorted.map(n => `<option value="${n}">${n}</option>`).join('');
                if (ui.categoryExpense) ui.categoryExpense.innerHTML = expenseCatsSorted.map(c => `<option value="${c}">${c}</option>`).join('');
                if (ui.categorySaving) {
                    let savingOptions = savingCatsSorted.map(c => `<option value="${c}">${c}</option>`);
                    if (goalsSorted.length) savingOptions = savingOptions.concat(goalsSorted.map(g => `<option value="${g}">${g} (Meta)</option>`));
                    ui.categorySaving.innerHTML = savingOptions.join('');
                }
            } catch (e) { console.error('populateDropdowns', e); }
        }

        function toggleTransactionType(type) {
            try {
                if (!ui.transactionTypeInput) return;
                ui.transactionTypeInput.value = type;
                if (ui.modalTypeToggles) ui.modalTypeToggles.forEach(btn => btn.classList.toggle('tab-active', btn.dataset.type === type));
                if (ui.expenseFields) {
                    ui.expenseFields.classList.toggle('hidden', type !== 'expenses');
                    ui.expenseFields.classList.toggle('section-hidden-smooth', type !== 'expenses');
                }
                if (ui.savingFields) {
                    ui.savingFields.classList.toggle('hidden', type !== 'savings');
                    ui.savingFields.classList.toggle('section-hidden-smooth', type !== 'savings');
                }
                // Show salary section only for incomes
                const salarySection = document.getElementById('salary-section');
                const isSalaryCheckbox = document.getElementById('is-salary');
                const salaryFields = document.getElementById('salary-fields');
                if (salarySection) salarySection.classList.toggle('hidden', type !== 'incomes');
                // When switching types away from incomes, reset salary checkbox and hide fields
                if (type !== 'incomes' && isSalaryCheckbox) {
                    isSalaryCheckbox.checked = false;
                    if (salaryFields) salaryFields.classList.add('hidden');
                    try { const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.remove('modal-expanded'); } catch(e){}
                }
                // If switching to incomes and the salary checkbox exists and is checked, expand modal
                if (type === 'incomes' && isSalaryCheckbox && isSalaryCheckbox.checked) {
                    try { const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.add('modal-expanded'); } catch(e){}
                }
                if (ui.advancedOptions) ui.advancedOptions.classList.remove('hidden');
                if (ui.installmentsSection) ui.installmentsSection.classList.toggle('hidden', type !== 'expenses');
                // Adjust financing visibility
                if (ui.financingSection) ui.financingSection.classList.toggle('hidden', type !== 'expenses');
            } catch (e) { console.error('toggleTransactionType', e); }
        }

        function toggleInstallmentSection(paymentMethodName) {
            try {
                const method = (state.appData.settings.paymentMethods || []).find(p => p.name === paymentMethodName);
                if (ui.installmentsSection) ui.installmentsSection.classList.toggle('hidden', !method || method.type !== 'credit_card');
                // financing section only for expenses
                if (ui.financingSection && ui.transactionTypeInput && ui.transactionTypeInput.value === 'expenses') {
                    ui.financingSection.classList.remove('hidden');
                    const financingCheckbox = document.getElementById('is-financing');
                    if (financingCheckbox) financingCheckbox.onchange = function() { document.getElementById('financing-fields').classList.toggle('hidden', !this.checked); };
                }
            } catch (e) { console.error('toggleInstallmentSection', e); }
        }

        // Reset transaction modal inputs to sensible defaults
        function resetTransactionModalDefaults() {
            try {
                // Default payment: first debit method if available, else first paymentMethod
                const payments = (state.appData.settings && state.appData.settings.paymentMethods) || [];
                let defaultPayment = '';
                try {
                    const debit = payments.find(p => (p.type || '').toString().toLowerCase() === 'debit');
                    if (debit) defaultPayment = debit.name;
                } catch(e) {}
                if (!defaultPayment && payments.length) defaultPayment = payments[0].name || '';
                // Fallbacks
                if (!defaultPayment) defaultPayment = 'Pix';
                if (document.getElementById('payment-method')) document.getElementById('payment-method').value = defaultPayment;
                // Default category: Contas if exists, else first expense category
                const expenseCats = (state.appData.settings && state.appData.settings.expenseCategories) || [];
                let defaultCat = expenseCats.find(c => (c||'').toString().toLowerCase().includes('conta')) || expenseCats[0] || 'Contas';
                if (document.getElementById('category-expense')) document.getElementById('category-expense').value = defaultCat;
                // Uncheck recurring and financing/installment checkboxes and hide fields
                const recurring = document.getElementById('is-recurring'); if (recurring) recurring.checked = false;
                const instal = document.getElementById('is-installment'); if (instal) instal.checked = false; const instFields = document.getElementById('installments-fields'); if (instFields) instFields.classList.add('hidden');
                const financ = document.getElementById('is-financing'); if (financ) financ.checked = false; const financFields = document.getElementById('financing-fields'); if (financFields) financFields.classList.add('hidden');
                // Clear description and amount inputs
                const desc = document.getElementById('description'); if (desc) desc.value = '';
                const amt = document.getElementById('amount'); if (amt) amt.value = '';
                // Reset modal-expanded class
                try { const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.remove('modal-expanded'); } catch(e){}
            } catch (e) { console.error('resetTransactionModalDefaults', e); }
        }

        // Prepare modal inputs for the next entry: prefer session last-used values when present
        function prepareModalForNextEntry() {
            try {
                // If session has last defaults, use them
                if (ui.lastTransactionDefaults && typeof ui.lastTransactionDefaults === 'object') {
                    const d = ui.lastTransactionDefaults;
                    if (document.getElementById('payment-method') && d.payment) document.getElementById('payment-method').value = d.payment;
                    if (document.getElementById('category-expense') && d.category) document.getElementById('category-expense').value = d.category;
                    return;
                }
                // otherwise apply global defaults
                resetTransactionModalDefaults();
            } catch (e) { console.error('prepareModalForNextEntry', e); }
        }

        function populateModal(type, id) {
            try {
                const transaction = getCurrentMonthData()[type].find(t => t.id === id);
                if (!transaction) return;
                document.getElementById('transaction-id').value = transaction.id || '';
                document.getElementById('description').value = transaction.description || '';
                document.getElementById('amount').value = transaction.amount || '';
                document.getElementById('is-recurring').checked = !!transaction.isRecurring;
                if (type === 'expenses') {
                    if (document.getElementById('payment-method')) document.getElementById('payment-method').value = transaction.payment || '';
                    if (document.getElementById('category-expense')) document.getElementById('category-expense').value = transaction.category || '';
                    if (transaction.financingId) {
                        const financingCheckbox = document.getElementById('is-financing');
                        if (financingCheckbox) {
                            financingCheckbox.checked = true;
                            // ensure the financing fields are shown (some handlers show/hide on change)
                            if (typeof financingCheckbox.onchange === 'function') financingCheckbox.onchange();
                            const ff = document.getElementById('financing-fields'); if (ff) ff.classList.remove('hidden');
                        }
                        const ft = document.getElementById('financing-total'); if (ft) ft.value = transaction.totalFinancing || '';
                        const fc = document.getElementById('financing-current'); if (fc) fc.value = transaction.currentFinancing || '';
                    }
                } else if (type === 'savings') {
                    if (document.getElementById('category-saving')) document.getElementById('category-saving').value = transaction.category || '';
                } else if (type === 'incomes') {
                    // If this income was created as part of a salary breakdown, it may carry salaryMeta
                    if (transaction.source && transaction.salaryMeta) {
                        // Open salary section and prefill fields
                        const isSalaryCheckbox = document.getElementById('is-salary');
                        const salaryFields = document.getElementById('salary-fields');
                        try {
                            if (isSalaryCheckbox) {
                                isSalaryCheckbox.checked = true;
                                if (salaryFields) salaryFields.classList.remove('hidden');
                                // expand modal when editing salary-related income
                                const modal = document.getElementById('transaction-modal'); if (modal) modal.classList.add('modal-expanded');
                            }
                        } catch(e){}
                        const meta = transaction.salaryMeta || {};
                        // Only fill main salary inputs when source is 'salary' (salary líquido)
                        if (transaction.source === 'salary') {
                            document.getElementById('salary-base').value = meta.salarioBase || '';
                            document.getElementById('salary-periculosidade').value = meta.percentualPericulosidade || '';
                            document.getElementById('salary-outros-proventos').value = meta.outrosProventosTributaveis || '';
                            document.getElementById('salary-dependentes').value = meta.numeroDependentes || '';
                            document.getElementById('salary-desjejum-dia').value = meta.valorDesjejumDia || '';
                            document.getElementById('salary-transporte-dia').value = meta.valorTransporteDia || '';
                            document.getElementById('salary-dias-trabalhados').value = meta.diasTrabalhados || '';
                            document.getElementById('salary-jornada-horas').value = meta.jornadaMensalHoras || '';
                            document.getElementById('salary-horas-trabalhadas').value = meta.horasTrabalhadas || '';
                        }
                        // For benefit entries (VT/VR) we keep them editable per-month (they are not auto-recurring when edited)
                        // but we still show salary meta so user can edit if needed.
                    }
                }
            } catch (e) { console.error('populateModal', e); }
        }

        function openGoalModal(id = null) {
            try {
                const modal = ui.goalModal;
                if (!modal) return;
                const form = ui.goalForm;
                if (form) form.reset();
                if (id) {
                    const goal = (state.appData.settings.goals || []).find(g => g.id === id);
                    if (goal) {
                        document.getElementById('goal-id').value = goal.id;
                        document.getElementById('goal-name').value = goal.name || '';
                        document.getElementById('goal-amount').value = goal.amount || '';
                        document.getElementById('goal-modal-title').textContent = 'Editar Meta';
                    }
                } else {
                    document.getElementById('goal-modal-title').textContent = 'Nova Meta';
                }
                modal.showModal();
            } catch (e) { console.error('openGoalModal', e); }
        }

        // Monthly and Annual report helpers
        function openMonthlyReport() {
            try {
                // Build and show monthly report modal
                const monthData = getCurrentMonthData();
                const totalIncome = (monthData.incomes || []).reduce((s,t)=>s+(t.amount||0),0);
                const totalOutcome = ((monthData.expenses || []).reduce((s,t)=>s+(t.amount||0),0)) + ((monthData.savings || []).reduce((s,t)=>s+(t.amount||0),0));
                const finalBalance = totalIncome - totalOutcome;
                const title = document.getElementById('monthly-report-title'); if (title) title.textContent = state.currentDate.toLocaleString('pt-BR', { month: 'long', year: 'numeric' });
                const inEl = document.getElementById('mr-total-income'); if (inEl) inEl.textContent = formatCurrency(totalIncome);
                const outEl = document.getElementById('mr-total-outcome'); if (outEl) outEl.textContent = formatCurrency(totalOutcome);
                const finEl = document.getElementById('mr-final-balance'); if (finEl) finEl.textContent = formatCurrency(finalBalance);
                renderMonthlySavingsChart();
                renderMonthlyReportCategoryChart();
                // Populate top expenses list
                try {
                    const topList = document.getElementById('mr-top-expenses-list');
                    if (topList) {
                        topList.innerHTML = '';
                        const topExpenses = (monthData.expenses || []).slice().sort((a,b)=> (b.amount||0)-(a.amount||0)).slice(0,8);
                        if (topExpenses.length === 0) topList.innerHTML = '<li class="text-gray-500">Nenhuma despesa registrada.</li>';
                        topExpenses.forEach(exp => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between';
                            li.innerHTML = `<span>${exp.description}</span><span class="font-medium">${formatCurrency(exp.amount)}</span>`;
                            topList.appendChild(li);
                        });
                    }
                } catch(e){console.error('populate top expenses', e)}
                const modal = ui.monthlyReportModal; if (modal) modal.showModal();
            } catch(e){console.error('openMonthlyReport', e)}
        }

        function openAnnualReport() {
            try {
                const year = state.currentDate.getFullYear();
                document.getElementById('annual-report-title').textContent = year;
                // compute yearly totals
                const yearData = state.appData.data[year] || {};
                const months = Object.keys(yearData);
                let totalInc = 0, totalOut = 0;
                months.forEach(m => {
                    const md = yearData[m] || { incomes: [], expenses: [], savings: [] };
                    totalInc += (md.incomes || []).reduce((s,t)=>s+(t.amount||0),0);
                    totalOut += ((md.expenses || []).reduce((s,t)=>s+(t.amount||0),0)) + ((md.savings || []).reduce((s,t)=>s+(t.amount||0),0));
                });
                const final = totalInc - totalOut;
                const inEl = document.getElementById('ar-total-income'); if (inEl) inEl.textContent = formatCurrency(totalInc);
                const outEl = document.getElementById('ar-total-outcome'); if (outEl) outEl.textContent = formatCurrency(totalOut);
                const finEl = document.getElementById('ar-final-balance'); if (finEl) finEl.textContent = formatCurrency(final);
                // Render annual charts
                renderAnnualBalanceEvolutionChart();
                renderAnnualAvgCategoryChart();
                const modal = ui.annualReportModal; if (modal) modal.showModal();
            } catch(e){console.error('openAnnualReport', e)}
        }

        function renderMonthlySavingsChart() {
            try {
                destroyChart('monthly-savings-chart');
                const yearData = state.appData.data[state.currentDate.getFullYear()] || {};
                const months = Array.from({ length: 12 }, (_, i) => String(i + 1).padStart(2, '0'));
                const monthlySavings = months.map(month => (yearData[month]?.savings || []).reduce((s,t)=>s+(t.amount||0),0));
                const ctx = document.getElementById('monthly-savings-chart'); if (!ctx || typeof Chart === 'undefined') return;
                ui.charts['monthly-savings-chart'] = new Chart(ctx.getContext('2d'), { type:'line', data:{ labels:['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'], datasets:[{ label:'Aportes Mensais', data: monthlySavings, borderColor:'#4F46E5', tension:0.1 }] }, options:{responsive:true, maintainAspectRatio:false} });
            } catch(e){console.error('renderMonthlySavingsChart', e)}
        }

        async function handleGoalFormSubmit(e) {
            try {
                e.preventDefault();
                const id = document.getElementById('goal-id').value;
                const name = document.getElementById('goal-name').value;
                const amount = parseFloat(document.getElementById('goal-amount').value) || 0;
                if (!state.appData.settings.goals) state.appData.settings.goals = [];
                if (id) {
                    const g = state.appData.settings.goals.find(x=>x.id===id);
                    if (g) { g.name = name; g.amount = amount; }
                } else {
                    state.appData.settings.goals.push({ id: generateUUID(), name, amount });
                }
                try {
                    await storage.saveData(state.appData);
                } catch (e) {
                    console.error('Erro ao salvar meta:', e);
                    showToast('Falha ao salvar meta no Firebase.', 'bg-red-600');
                }
                closeModal('goal-modal');
                renderInvestmentsView();
            } catch(e){console.error('handleGoalFormSubmit', e)}
        }

        // --- LÓGICA DE TRANSAÇÕES (Adicionar, Editar, Excluir) ---

        // Funções auxiliares (definidas antes do uso para evitar ReferenceError)
        function updateFutureRecurrences(recurringId, newTransaction, type) {
            Object.keys(state.appData.data).forEach(year => {
                Object.keys(state.appData.data[year]).forEach(month => {
                    const monthData = state.appData.data[year][month];
                    if (monthData[type] && Array.isArray(monthData[type])) {
                        monthData[type] = monthData[type].map(item => {
                            const itemDate = new Date(year, month - 1);
                            if (item.recurringId === recurringId && itemDate > state.currentDate) {
                                return { 
                                    ...item, 
                                    description: newTransaction.description,
                                    amount: newTransaction.amount,
                                    category: newTransaction.category,
                                    payment: newTransaction.payment,
                                    type: newTransaction.type
                                };
                            }
                            return item;
                        });
                    }
                });
            });
        }

        // Rebuild future financing installments when the user edits an installment.
        // This will remove future installments (after the original edited one) and
        // recreate them starting from the edited installment's month using the
        // edited currentFinancing and totalFinancing values. This keeps numbering
        // and dates consistent with user's edit (e.g. changing current installment
        // to a different number will shift the schedule).
        function updateAllFinancing(financingId, originalCurrentFinancing, newTransaction) {
            try {
                const newCurrent = Number(newTransaction.currentFinancing) || originalCurrentFinancing;
                const newTotal = Number(newTransaction.totalFinancing) || null;
                if (!newTotal || newTotal < newCurrent) return;

                // Edited installment month (we edit the transaction in the currently viewed month)
                const editedMonthStart = new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), 1);

                // 1) Remove any future installments that belong to this financing and are scheduled after the edited month
                Object.keys(state.appData.data).forEach(year => {
                    Object.keys(state.appData.data[year]).forEach(month => {
                        const monthStart = new Date(Number(year), Number(month) - 1, 1);
                        const monthData = state.appData.data[year][month];
                        if (monthData.expenses && Array.isArray(monthData.expenses)) {
                            monthData.expenses = monthData.expenses.filter(exp => {
                                if (exp.financingId !== financingId) return true;
                                // keep installments that are in or before the edited month; remove those after
                                return monthStart <= editedMonthStart;
                            });
                        }
                    });
                });

                // 2) Recreate installments from newCurrent+1 .. newTotal starting from edited month + 1
                for (let k = newCurrent + 1; k <= newTotal; k++) {
                    const monthOffset = k - newCurrent; // 1 => next month
                    const targetDate = new Date(editedMonthStart);
                    targetDate.setMonth(editedMonthStart.getMonth() + monthOffset);
                    const targetMonthData = getCurrentMonthData(targetDate);
                    if (!Array.isArray(targetMonthData.expenses)) targetMonthData.expenses = [];

                    const newInst = {
                        ...newTransaction,
                        id: generateUUID(),
                        financingId: financingId,
                        currentFinancing: k,
                        totalFinancing: newTotal,
                        isPaid: false
                    };

                    targetMonthData.expenses.push(newInst);
                }
            } catch (e) {
                console.error('updateAllFinancing (rebuild) error', e);
            }
        }
        
    // createInstallments(baseTransaction, count, start) - start: current installment number (default 1)
    async function createInstallments(baseTransaction, count, start = 1) {
            const installmentId = generateUUID();
            // If a start/current installment > 1 is provided, the user is registering
            // an in-progress parcel and expects the provided amount to be the
            // per-installment value (do NOT divide by total). Otherwise divide
            // the provided amount evenly across total installments.
            let installmentAmount;
            const rawAmount = parseFloat(baseTransaction.amount) || 0;
            if (start && start > 1) {
                installmentAmount = parseFloat(rawAmount.toFixed(2));
            } else {
                installmentAmount = parseFloat((rawAmount / count).toFixed(2));
            }
            // Do not create previous installments automatically.

            // create installments numbered start..count (inclusive)
            for (let i = start; i <= count; i++) {
                // Determine month offset: installment i corresponds to month offset (i - start)
                const monthOffset = i - start;
                const installmentDate = new Date(state.currentDate);
                installmentDate.setMonth(state.currentDate.getMonth() + monthOffset);
                const futureMonthData = getCurrentMonthData(installmentDate);
                // If payment method is VR, store as vrUsage entry instead of expenses
                    if ((baseTransaction.payment || '') === 'VR') {
                    if (!Array.isArray(futureMonthData.vrUsage)) futureMonthData.vrUsage = [];
                    futureMonthData.vrUsage.push({ id: generateUUID(), amount: installmentAmount, description: baseTransaction.description || 'Despesa VR', date: new Date(installmentDate).toISOString(), installmentId, currentInstallment: i, totalInstallments: count, isPaid: i < start ? true : false });
                }
                // If payment method is VT, mirror VR behavior and store in vtUsage ledger
                else if ((baseTransaction.payment || '') === 'VT') {
                    if (!Array.isArray(futureMonthData.vtUsage)) futureMonthData.vtUsage = [];
                    futureMonthData.vtUsage.push({ id: generateUUID(), amount: installmentAmount, description: baseTransaction.description || 'Despesa VT', date: new Date(installmentDate).toISOString(), installmentId, currentInstallment: i, totalInstallments: count, isPaid: i < start ? true : false });
                } else {
                    if (!Array.isArray(futureMonthData.expenses)) futureMonthData.expenses = [];
                    futureMonthData.expenses.push({ 
                        ...baseTransaction, 
                        id: generateUUID(), 
                        amount: installmentAmount, 
                        installmentId, 
                        currentInstallment: i, 
                        totalInstallments: count, 
                        isPaid: i < start ? true : false 
                     });
                }
            }
            try {
                await storage.saveData(state.appData);
                showToast(`${count} parcelas criadas com sucesso!`, 'bg-green-600');
            } catch (e) {
                console.error('Erro ao criar parcelas:', e);
                showToast('Falha ao salvar parcelas no Firebase.', 'bg-red-600');
            }
        }

    async function createFinancing(baseTransaction, total, current) {
            const financingId = generateUUID();
            for (let i = current; i <= total; i++) {
                const installmentDate = new Date(state.currentDate);
                installmentDate.setMonth(state.currentDate.getMonth() + (i - current));
                const futureMonthData = getCurrentMonthData(installmentDate);
                if ((baseTransaction.payment || '') === 'VR') {
                    if (!Array.isArray(futureMonthData.vrUsage)) futureMonthData.vrUsage = [];
                    futureMonthData.vrUsage.push({ id: generateUUID(), amount: parseFloat(baseTransaction.amount) || 0, description: baseTransaction.description || 'Despesa VR', date: new Date(installmentDate).toISOString(), financingId, currentFinancing: i, totalFinancing: total });
                }
                else if ((baseTransaction.payment || '') === 'VT') {
                    if (!Array.isArray(futureMonthData.vtUsage)) futureMonthData.vtUsage = [];
                    futureMonthData.vtUsage.push({ id: generateUUID(), amount: parseFloat(baseTransaction.amount) || 0, description: baseTransaction.description || 'Despesa VT', date: new Date(installmentDate).toISOString(), financingId, currentFinancing: i, totalFinancing: total });
                } else {
                    if (!Array.isArray(futureMonthData.expenses)) futureMonthData.expenses = [];
                    futureMonthData.expenses.push({
                        ...baseTransaction,
                        id: generateUUID(),
                        financingId,
                        currentFinancing: i,
                        totalFinancing: total
                    });
                }
            }
            try {
                await storage.saveData(state.appData);
                showToast(`Financiamento de ${total} parcelas criado!`, 'bg-green-600');
            } catch (e) {
                console.error('Erro ao criar financiamento:', e);
                showToast('Falha ao salvar financiamento no Firebase.', 'bg-red-600');
            }
        }

        function deleteFutureInstallments(installmentId, currentInstallment) {
            Object.keys(state.appData.data).forEach(year => {
                Object.keys(state.appData.data[year]).forEach(month => {
                    const monthData = state.appData.data[year][month];
                    if (monthData.expenses && Array.isArray(monthData.expenses)) {
                        monthData.expenses = monthData.expenses.filter(exp => 
                            !(exp.installmentId === installmentId && exp.currentInstallment >= currentInstallment)
                        );
                    }
                });
            });
        }

        function deleteFutureFinancing(financingId, fromCurrentFinancing) {
            Object.keys(state.appData.data).forEach(year => {
                Object.keys(state.appData.data[year]).forEach(month => {
                    const monthData = state.appData.data[year][month];
                    if (monthData.expenses && Array.isArray(monthData.expenses)) {
                        monthData.expenses = monthData.expenses.filter(exp => 
                            !(exp.financingId === financingId && (exp.currentFinancing || 0) >= fromCurrentFinancing)
                        );
                    }
                });
            });
        }

        function deleteFutureRecurrences(recurringId) {
            const currentMonthStart = new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), 1);
            Object.keys(state.appData.data).forEach(year => {
                Object.keys(state.appData.data[year]).forEach(month => {
                    const monthStart = new Date(year, month - 1, 1);
                    if (monthStart >= currentMonthStart) {
                        const monthData = state.appData.data[year][month];
                        ['incomes', 'expenses', 'savings'].forEach(type => {
                            if (monthData[type] && Array.isArray(monthData[type])) {
                                monthData[type] = monthData[type].filter(item => item.recurringId !== recurringId);
                            }
                        });
                    }
                });
            });
        }

        // Função principal para salvar (adicionar ou editar)
        async function saveTransaction(transaction, type, id) {
            const currentMonthData = getCurrentMonthData();
            if (!Array.isArray(currentMonthData[type])) currentMonthData[type] = [];

            if (id) { // Editando
                const index = currentMonthData[type].findIndex(t => t.id === id);
                if (index > -1) {
                    const originalTransaction = currentMonthData[type][index];
                    
                    // Preserva IDs importantes que não devem mudar na edição
                    transaction.recurringId = originalTransaction.recurringId;
                    transaction.financingId = originalTransaction.financingId;
                    transaction.installmentId = originalTransaction.installmentId;

                    if (originalTransaction.recurringId) {
                        if (confirm('Esta é uma transação recorrente. Deseja atualizar as futuras também?')) {
                            updateFutureRecurrences(originalTransaction.recurringId, transaction, type);
                        }
                    }

                    if (originalTransaction.financingId) {
                        if (confirm('Esta é uma transação de financiamento. Deseja atualizar as parcelas futuras também?')) {
                            updateAllFinancing(originalTransaction.financingId, originalTransaction.currentFinancing, transaction);
                        }
                    }

                    currentMonthData[type][index] = { ...originalTransaction, ...transaction };
                    try {
                        await storage.saveData(state.appData);
                        showToast('Transação editada com sucesso!', 'bg-green-600');
                    } catch (e) {
                        console.error('Erro ao salvar transação editada:', e);
                        showToast('Falha ao salvar transação no Firebase.', 'bg-red-600');
                    }
                }
            } else { // Adicionando
                if (transaction.isRecurring) {
                    transaction.recurringId = generateUUID();
                }
                currentMonthData[type].push(transaction);
                try {
                    await storage.saveData(state.appData);
                    showToast('Transação salva com sucesso!', 'bg-green-600');
                    // Persist session 'last used' payment/category for faster subsequent entries (in-memory only)
                    try {
                        const lastPayment = document.getElementById('payment-method') ? document.getElementById('payment-method').value : null;
                        const lastCat = document.getElementById('category-expense') ? document.getElementById('category-expense').value : null;
                        ui.lastTransactionDefaults = { payment: lastPayment, category: lastCat };
                    } catch(e) { /* ignore */ }
                    // Prepare modal for next entry using session defaults (will fall back to app defaults on reload)
                    try { prepareModalForNextEntry(); } catch(e) { console.error('prepare next after save', e); }
                } catch (e) {
                    console.error('Erro ao salvar nova transação:', e);
                    showToast('Falha ao salvar transação no Firebase.', 'bg-red-600');
                }
            }
        }

    // Função principal para excluir
    async function deleteTransaction(type, id) {
            const currentMonthData = getCurrentMonthData();
            if (!Array.isArray(currentMonthData[type])) return;
            
            const transaction = currentMonthData[type].find(t => t.id === id);
            if (!transaction) return;

            let confirmMessage = 'Tem certeza que deseja excluir esta transação?';
            let action = () => {
                const index = currentMonthData[type].findIndex(t => t.id === id);
                if (index > -1) currentMonthData[type].splice(index, 1);
                return 'Transação excluída com sucesso!';
            };

            if (transaction.installmentId) {
                // Ask the user whether to delete only this installment or this + future installments
                const deleteOnlyThis = confirm('Esta é uma transação parcelada. Deseja excluir apenas esta parcela? (OK = Sim, Cancel = Não)');
                if (deleteOnlyThis) {
                    confirmMessage = 'Confirma exclusão desta parcela?';
                    action = () => {
                        const index = currentMonthData[type].findIndex(t => t.id === id);
                        if (index > -1) currentMonthData[type].splice(index, 1);
                        return 'Parcela excluída com sucesso!';
                    };
                } else {
                    const deleteFuture = confirm('Deseja excluir esta e todas as parcelas futuras? (OK = Sim, Cancel = Não)');
                    if (deleteFuture) {
                        confirmMessage = 'Confirma exclusão desta e das parcelas futuras?';
                        action = () => {
                            deleteFutureInstallments(transaction.installmentId, transaction.currentInstallment);
                            return 'Parcelas excluídas com sucesso!';
                        };
                    } else {
                        // user cancelled
                        return;
                    }
                }
            } else if (transaction.financingId) {
                // Financing case: offer to delete only this financing installment or this + future financing installments
                const delOnly = confirm('Esta é uma parcela de financiamento. Deseja excluir apenas esta parcela? (OK = Sim, Cancel = Não)');
                if (delOnly) {
                    confirmMessage = 'Confirma exclusão desta parcela?';
                    action = () => {
                        const index = currentMonthData[type].findIndex(t => t.id === id);
                        if (index > -1) currentMonthData[type].splice(index, 1);
                        return 'Parcela excluída com sucesso!';
                    };
                } else {
                    const delFuture = confirm('Deseja excluir esta e todas as parcelas futuras do financiamento? (OK = Sim, Cancel = Não)');
                    if (delFuture) {
                        confirmMessage = 'Confirma exclusão desta e das parcelas futuras do financiamento?';
                        action = () => {
                            deleteFutureFinancing(transaction.financingId, transaction.currentFinancing);
                            return 'Parcelas de financiamento excluídas com sucesso!';
                        };
                    } else {
                        return;
                    }
                }
            } else if (transaction.recurringId) {
                confirmMessage = 'Esta é uma transação recorrente. Deseja excluir esta e todas as futuras recorrências (a partir deste mês)?';
                action = () => {
                    deleteFutureRecurrences(transaction.recurringId);
                    return 'Recorrências excluídas com sucesso!';
                };
            }

            if (confirm(confirmMessage)) {
                const toastMessage = action();
                try {
                    await storage.saveData(state.appData);
                    showToast(toastMessage, 'bg-red-600');
                } catch (e) {
                    console.error('Erro ao excluir transação:', e);
                    showToast('Falha ao salvar exclusão no Firebase.', 'bg-red-600');
                }
                render();
            }
        }

        // Ponto de entrada do formulário
        async function handleFormSubmit(e) {
            e.preventDefault();
            const id = document.getElementById('transaction-id').value;
            const type = ui.transactionTypeInput.value;

            const transactionData = {
                description: document.getElementById('description').value,
                amount: parseFloat(document.getElementById('amount').value),
                isRecurring: document.getElementById('is-recurring').checked
            };

            if (!id) transactionData.id = generateUUID();

            if (type === 'expenses') {
                Object.assign(transactionData, {
                    payment: document.getElementById('payment-method').value,
                    category: document.getElementById('category-expense').value,
                    type: document.getElementById('expense-type').value,
                    isPaid: false
                });
                // If financing fields are present in the modal, include them
                const financingCheckbox = document.getElementById('is-financing');
                if (financingCheckbox && financingCheckbox.checked) {
                    const totalFin = parseInt(document.getElementById('financing-total').value, 10);
                    const currentFin = parseInt(document.getElementById('financing-current').value, 10);
                    if (!isNaN(totalFin)) transactionData.totalFinancing = totalFin;
                    if (!isNaN(currentFin)) transactionData.currentFinancing = currentFin;
                    // Keep financingId if editing
                    const existingFId = document.getElementById('transaction-id').value;
                    if (existingFId) transactionData.financingId = currentFin ? (transactionData.financingId || null) : transactionData.financingId;
                }
                // If payment method is VR, ensure category is Alimentação (or equivalent), mark as paid and record usage in current month's vrUsage ledger
                const pm = transactionData.payment || '';
                if (pm === 'VR') {
                    // Mark VR expenses as already paid (VR behaves like debit)
                    transactionData.isPaid = true;
                    const settings = state.appData.settings || {};
                    const expenseCategories = settings.expenseCategories || [];
                    // try to find an 'Alimentação' category (case-insensitive, accent-insensitive)
                    const normalize = s => (s || '').toString().toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
                    const foundAlim = expenseCategories.find(c => normalize(c).includes('aliment'));
                    const currentCat = transactionData.category || '';
                    if (!normalize(currentCat).includes('aliment')) {
                        if (foundAlim) {
                            // Auto-set to the found Alimentação category
                            transactionData.category = foundAlim;
                            showToast('Pagamento via VR: categoria ajustada para Alimentação.', 'bg-yellow-600');
                        } else {
                            // Warn user but allow save
                            if (!confirm('Você selecionou VR como forma de pagamento, mas a categoria não parece ser Alimentação. Deseja prosseguir?')) {
                                // Cancel submit by returning early
                                return;
                            }
                        }
                    }
                    // Force type to Essenciais when paying with VR
                    try { transactionData.type = 'Essenciais'; } catch(e) { /* ignore */ }
                    // Validate VR balance: do not allow expense > available VR balance for current month
                    const mdCheck = getCurrentMonthData();
                    let availableVR = getMonthVRBalance(mdCheck);
                    // If editing an existing VR expense, add back the original amount so the validation allows reducing/increasing within the original envelope
                    if (id) {
                        try {
                            const existing = mdCheck.expenses && mdCheck.expenses.find(e => e.id === id);
                            if (existing && existing.payment === 'VR') {
                                availableVR = Math.round((availableVR + (Number(existing.amount) || 0)) * 100) / 100;
                            }
                        } catch (e) { console.error('adjust availableVR for edit', e); }
                    }
                    const spendAmount = Number(transactionData.amount) || 0;
                    if (spendAmount > availableVR) {
                        // Show inline error in modal so the user can immediately see the problem
                        setTransactionError('Valor superior ao saldo disponível de VR para este mês. Verifique o saldo no card de VR.');
                        return; // block save
                    } else {
                        clearTransactionError();
                    }
                        // Instead of saving this as a normal expense, store it in the month's vrUsage ledger
                        const md = getCurrentMonthData();
                        if (!Array.isArray(md.vrUsage)) md.vrUsage = [];
                        const usageEntry = { id: generateUUID(), amount: Number(transactionData.amount) || 0, description: transactionData.description || '', date: new Date().toISOString() };
                        md.vrUsage.push(usageEntry);
                        // Persist immediately and bail out of the normal expense save flow
                        try {
                            await storage.saveData(state.appData);
                            showToast('Despesa registrada no VR (lançamento separado).', 'bg-green-600');
                        } catch (e) {
                            console.error('Erro ao salvar uso de VR:', e);
                            showToast('Falha ao salvar uso de VR no Firebase.', 'bg-red-600');
                        }
                        // Close modal and re-render instead of continuing to add to expenses
                        closeModal('transaction-modal');
                        render();
                        return;
                }
                // VT mirror of VR: store VT purchases in vtUsage ledger (do not add to expenses)
                if (pm === 'VT') {
                    // Mark VT purchases similar to VR (treated as immediate debit)
                    transactionData.isPaid = true;
                    // Ensure category is Transporte (if not already)
                    try {
                        const settings = state.appData.settings || {};
                        const expenseCategories = settings.expenseCategories || [];
                        const normalize = s => (s || '').toString().toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
                        const foundTransp = expenseCategories.find(c => normalize(c).includes('transport')) || expenseCategories.find(c => normalize(c).includes('transp')) || expenseCategories.find(c => normalize(c).includes('transporte'));
                        const currentCat = transactionData.category || '';
                        if (!normalize(currentCat).includes('transp') && foundTransp) {
                            transactionData.category = foundTransp;
                            showToast('Pagamento via VT: categoria ajustada para Transporte.', 'bg-yellow-600');
                        }
                    } catch (e) { console.error('vt category enforcement', e); }

                    // If description empty, set to Abastecimento
                    if (!transactionData.description || transactionData.description.trim() === '') {
                        transactionData.description = 'Abastecimento';
                    }

                    // Validate VT balance similar to VR
                    const mdCheck = getCurrentMonthData();
                    let availableVT = getMonthVTBalance(mdCheck);
                    if (id) {
                        try {
                            const existing = (mdCheck.expenses || []).find(e => e.id === id);
                            if (existing && existing.payment === 'VT') {
                                availableVT = Math.round((availableVT + (Number(existing.amount) || 0)) * 100) / 100;
                            }
                        } catch (e) { console.error('adjust availableVT for edit', e); }
                    }
                    const spendAmount = Number(transactionData.amount) || 0;
                    if (spendAmount > availableVT) {
                        setTransactionError('Valor superior ao saldo disponível de VT para este mês. Verifique o saldo no card de VT.');
                        return;
                    } else {
                        clearTransactionError();
                    }

                    // Store in vtUsage ledger instead of expenses
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vtUsage)) md.vtUsage = [];
                    const usageEntry = { id: generateUUID(), amount: Number(transactionData.amount) || 0, description: transactionData.description || '', date: new Date().toISOString() };
                    md.vtUsage.push(usageEntry);
                    try {
                        await storage.saveData(state.appData);
                        showToast('Despesa registrada no VT (lançamento separado).', 'bg-green-600');
                    } catch (e) {
                        console.error('Erro ao salvar uso de VT:', e);
                        showToast('Falha ao salvar uso de VT no Firebase.', 'bg-red-600');
                    }
                    closeModal('transaction-modal');
                    render();
                    return;
                }
            } else if (type === 'savings') {
                Object.assign(transactionData, { category: document.getElementById('category-saving').value });
            }

            const isInstallment = document.getElementById('is-installment').checked;
            const installmentsCount = parseInt(document.getElementById('installments-count').value, 10);
            const isFinancing = document.getElementById('is-financing').checked;
            const financingTotal = parseInt(document.getElementById('financing-total').value, 10);
            const financingCurrent = parseInt(document.getElementById('financing-current').value, 10);

            try {
                const currentMonthData = getCurrentMonthData();
                // If editing an existing expense and user converted it to installments/financing, handle conversion
                if (id && type === 'expenses') {
                    const original = currentMonthData.expenses.find(t => t.id === id);
                    if (original) {
                        // Convert single expense -> installments
                        if (isInstallment && installmentsCount > 1 && !original.installmentId && !original.financingId) {
                            // remove original single transaction
                            const idx = currentMonthData.expenses.findIndex(t => t.id === id);
                            if (idx > -1) currentMonthData.expenses.splice(idx, 1);
                            const startInstallment = parseInt((document.getElementById('installments-current') || { value: 1 }).value, 10) || 1;
                            await createInstallments(transactionData, installmentsCount, startInstallment);
                            // done
                            closeModal('transaction-modal');
                            render();
                            return;
                        }
                        // Convert single expense -> financing
                        if (isFinancing && financingTotal > 1 && financingCurrent >= 1 && !original.financingId && !original.installmentId) {
                            const idx = currentMonthData.expenses.findIndex(t => t.id === id);
                            if (idx > -1) currentMonthData.expenses.splice(idx, 1);
                            await createFinancing(transactionData, financingTotal, financingCurrent);
                            closeModal('transaction-modal');
                            render();
                            return;
                        }
                    }
                }

                // Default flows for creating new or simple edits
                    if (type === 'expenses' && isInstallment && installmentsCount > 1 && !id) {
                    // console.debug('[handleFormSubmit] creating installments (new)', installmentsCount /*, transactionData */);
                    const startInstallment = parseInt((document.getElementById('installments-current') || { value: 1 }).value, 10) || 1;
                    await createInstallments(transactionData, installmentsCount, startInstallment);
                } else if (type === 'expenses' && isFinancing && financingTotal > 1 && financingCurrent >= 1 && !id) {
                    // console.debug('[handleFormSubmit] creating financing (new)', financingTotal, financingCurrent /*, transactionData */);
                    await createFinancing(transactionData, financingTotal, financingCurrent);
                } else if (type === 'incomes' && document.getElementById('is-salary') && document.getElementById('is-salary').checked) {
                // Special handling for salary: calculate breakdown and update/create entries
                try {
                        const year = state.currentDate.getFullYear();
                        const month = state.currentDate.getMonth() + 1;
                        // If salary-base not provided, prefer the main 'amount' field when description indicates salary
                        const amountFieldVal = parseFloat((document.getElementById('amount') || { value: 0 }).value) || 0;
                        const providedSalaryBase = parseFloat((document.getElementById('salary-base') || { value: 0 }).value) || 0;
                        const salarioBaseToUse = providedSalaryBase > 0 ? providedSalaryBase : amountFieldVal;

                        // read current recurring checkbox value at submit time
                        const isRecurringNow = document.getElementById('is-recurring') ? document.getElementById('is-recurring').checked : !!transactionData.isRecurring;

                        const params = {
                            salarioBase: salarioBaseToUse,
                            percentualPericulosidade: parseFloat((document.getElementById('salary-periculosidade') || { value: 0 }).value) || 0,
                            outrosProventosTributaveis: parseFloat((document.getElementById('salary-outros-proventos') || { value: 0 }).value) || 0,
                            numeroDependentes: parseInt((document.getElementById('salary-dependentes') || { value: 0 }).value, 10) || 0,
                            valorDesjejumDia: parseFloat((document.getElementById('salary-desjejum-dia') || { value: 0 }).value) || 0,
                            valorTransporteDia: parseFloat((document.getElementById('salary-transporte-dia') || { value: 0 }).value) || 0,
                            diasTrabalhados: parseInt((document.getElementById('salary-dias-trabalhados') || { value: '' }).value, 10) || undefined,
                            // hoursTrabalhadas is used to compute valorHora when provided; default handled inside calcularSalarioLiquido
                            hoursTrabalhadas: parseFloat((document.getElementById('salary-horas-trabalhadas') || { value: 0 }).value) || 0,
                            horasExtrasSabado: parseFloat((document.getElementById('salary-h-extra-sab') || { value: 0 }).value) || 0,
                            horasExtrasDomingo: parseFloat((document.getElementById('salary-h-extra-dom') || { value: 0 }).value) || 0,
                            jornadaMensalHoras: parseFloat((document.getElementById('salary-jornada-horas') || { value: 220 }).value) || 220,
                            // hoursTrabalhadas will be set/used inside calcularSalarioLiquido when needed
                            year, month
                        };
                        const calc = calcularSalarioLiquido(params);
                        // parse formatted numbers back to numeric values
                        const parseNum = (s) => { try { return typeof s === 'number' ? s : parseFloat(String(s).replace(/\./g, '').replace(',', '.')) || parseFloat(s); } catch(e){ return parseFloat(s) || 0; } };
                        // The function currently returns formatted strings in resumo; they use dot as decimal separator (toFixed)
                        const salarioLiquido = parseFloat(calc.resumo.salarioLiquido) || 0;
                        const beneficiosTotais = parseFloat(calc.resumo.beneficiosTotais) || 0;
                        const valorHorasExtras = parseFloat(calc.resumo.valorHorasExtras) || 0;

                        // create helper to build values for a given month
                        const buildValuesFor = (pMonthly) => {
                            const calcMonth = calcularSalarioLiquido(pMonthly);
                            const salarioLiquidoM = parseFloat(calcMonth.resumo.salarioLiquido) || 0;
                            const valorHorasExtrasM = parseFloat(calcMonth.resumo.valorHorasExtras) || 0;
                            // Benefits refer to the following month
                            const nextDate = new Date(pMonthly.year, pMonthly.month, 1);
                            const nextY2 = nextDate.getFullYear();
                            const nextM2 = nextDate.getMonth() + 1;
                            const roundLocal = (v) => Math.round((v + Number.EPSILON) * 100) / 100;
                            // VT: transporte benefit uses business days of next month (payment month)
                            const beneficiosVTM = roundLocal((pMonthly.valorTransporteDia || 0) * diasUteisNoMes(nextY2, nextM2));
                            // VR: per your rule, use dias úteis do MES ATUAL + 4 (to include saturdays equivalent)
                            const beneficiosVRM = roundLocal((pMonthly.valorDesjejumDia || 0) * (diasUteisNoMes(pMonthly.year, pMonthly.month) + 1));
                            return { salarioLiquido: salarioLiquidoM, beneficiosVT: beneficiosVTM, beneficiosVR: beneficiosVRM, valorHorasExtras: valorHorasExtrasM };
                        };

                        // helper to remove previous salary-generated items in a month by recurringId or by salaryMeta
                        const removeSalaryItemsFromMonth = (monthDataObj, opts) => {
                            if (!monthDataObj) return;
                            const oldMetaStr = opts.oldMetaStr || null;
                            const rid = opts.recurringId || null;
                            if (!Array.isArray(monthDataObj.incomes)) monthDataObj.incomes = [];
                            // Remove incomes that belong to the recurringId when provided
                            if (rid) {
                                monthDataObj.incomes = monthDataObj.incomes.filter(i => i.recurringId !== rid);
                                if (Array.isArray(monthDataObj.vrLedger)) monthDataObj.vrLedger = monthDataObj.vrLedger.filter(l => l.recurringId !== rid);
                            } else if (oldMetaStr) {
                                monthDataObj.incomes = monthDataObj.incomes.filter(i => !(i.salaryMeta && JSON.stringify(i.salaryMeta) === oldMetaStr));
                                if (Array.isArray(monthDataObj.vrLedger)) monthDataObj.vrLedger = monthDataObj.vrLedger.filter(l => !(l.salaryMeta && JSON.stringify(l.salaryMeta) === oldMetaStr));
                            }
                        };

                        // pushEntriesToMonth re-used (keeps salaryMeta on created items)
                        const pushEntriesToMonth = (monthDataObj, rId, values, meta) => {
                            if (!Array.isArray(monthDataObj.incomes)) monthDataObj.incomes = [];
                            const toPush = [];
                            if (values.salarioLiquido > 0) toPush.push({ id: generateUUID(), description: `Salário (Líquido)`, amount: values.salarioLiquido, isRecurring: !!transactionData.isRecurring, recurringId: rId, source: 'salary', salaryMeta: meta || null });
                            if (values.beneficiosVT > 0) toPush.push({ id: generateUUID(), description: `Benefício - VT`, amount: values.beneficiosVT, isRecurring: !!rId, recurringId: rId || null, source: 'benefit-vt', salaryMeta: meta || null });
                            if (values.beneficiosVR > 0) {
                                if (!Array.isArray(monthDataObj.vrLedger)) monthDataObj.vrLedger = [];
                                monthDataObj.vrLedger.push({ id: generateUUID(), description: 'Benefício - VR', amount: values.beneficiosVR, recurringId: rId || null, isRecurring: !!rId, salaryMeta: meta || null });
                            }
                            if (values.valorHorasExtras > 0) toPush.push({ id: generateUUID(), description: `Horas Extras`, amount: values.valorHorasExtras, isRecurring: !!transactionData.isRecurring, recurringId: rId, source: 'overtime', salaryMeta: meta || null });
                            toPush.forEach(en => monthDataObj.incomes.push(en));
                        };

                        // Now handle editing vs creating
                        if (id) {
                            // Editing an existing income: try to find the original salary income
                            const original = currentMonthData.incomes.find(t => t.id === id);
                            const oldMetaStr = original && original.salaryMeta ? JSON.stringify(original.salaryMeta) : null;
                            const origRecurringId = original && original.recurringId ? original.recurringId : null;
                            const applyToFuture = origRecurringId ? confirm('Essa é uma entrada recorrente. Deseja aplicar as alterações às recorrências futuras? (OK = Sim)') : false;

                            if (origRecurringId && applyToFuture) {
                                // Update this and future months for this recurringId
                                Object.keys(state.appData.data).forEach(yearKey => {
                                    Object.keys(state.appData.data[yearKey]).forEach(monthKey => {
                                        const monthStart = new Date(Number(yearKey), Number(monthKey) - 1, 1);
                                        const editedMonthStart = new Date(state.currentDate.getFullYear(), state.currentDate.getMonth(), 1);
                                        if (monthStart >= editedMonthStart) {
                                            const md = state.appData.data[yearKey][monthKey];
                                            // remove old recurring entries
                                            removeSalaryItemsFromMonth(md, { recurringId: origRecurringId });
                                            // compute pMonthly for this month
                                            const pMonthly = Object.assign({}, params, { year: Number(yearKey), month: Number(monthKey) });
                                            const vals = buildValuesFor(pMonthly);
                                            const meta = { salarioBase: pMonthly.salarioBase, percentualPericulosidade: pMonthly.percentualPericulosidade, outrosProventosTributaveis: pMonthly.outrosProventosTributaveis, numeroDependentes: pMonthly.numeroDependentes, valorDesjejumDia: pMonthly.valorDesjejumDia, valorTransporteDia: pMonthly.valorTransporteDia, diasTrabalhados: pMonthly.diasTrabalhados, horasTrabalhadas: pMonthly.hoursTrabalhadas, jornadaMensalHoras: pMonthly.jornadaMensalHoras };
                                            pushEntriesToMonth(md, origRecurringId, vals, meta);
                                        }
                                    });
                                });
                            } else {
                                // Update only current month
                                removeSalaryItemsFromMonth(currentMonthData, { oldMetaStr, recurringId: origRecurringId && !applyToFuture ? origRecurringId : null });
                                const pMonthlyNow = Object.assign({}, params, { year: state.currentDate.getFullYear(), month: state.currentDate.getMonth() + 1 });
                                const valsNow = buildValuesFor(pMonthlyNow);
                                const metaNow = { salarioBase: pMonthlyNow.salarioBase, percentualPericulosidade: pMonthlyNow.percentualPericulosidade, outrosProventosTributaveis: pMonthlyNow.outrosProventosTributaveis, numeroDependentes: pMonthlyNow.numeroDependentes, valorDesjejumDia: pMonthlyNow.valorDesjejumDia, valorTransporteDia: pMonthlyNow.valorTransporteDia, diasTrabalhados: pMonthlyNow.diasTrabalhados, horasTrabalhadas: pMonthlyNow.hoursTrabalhadas, jornadaMensalHoras: pMonthlyNow.jornadaMensalHoras };
                                // Keep original recurringId on this month if it existed
                                const targetRid = origRecurringId || (transactionData.isRecurring ? generateUUID() : null);
                                pushEntriesToMonth(currentMonthData, targetRid, valsNow, metaNow);
                            }

                            try { await storage.saveData(state.appData); showToast('Salário atualizado com sucesso!', 'bg-green-600'); } catch(e){ console.error('save edited salary', e); showToast('Falha ao salvar salário editado.', 'bg-red-600'); }
                        } else {
                            // Creating new salary entries (no id provided)
                            const recurringId = transactionData.isRecurring ? generateUUID() : null;
                            if (transactionData.isRecurring) {
                                const rId = recurringId;
                                for (let i = 0; i < 12; i++) {
                                    const d = new Date(state.currentDate.getFullYear(), state.currentDate.getMonth() + i, 1);
                                    const y = d.getFullYear();
                                    const m = d.getMonth() + 1;
                                    const pMonthly = Object.assign({}, params, { year: y, month: m });
                                    const vals = buildValuesFor(pMonthly);
                                    const md = getCurrentMonthData(new Date(y, m - 1, 1));
                                    const meta = { salarioBase: pMonthly.salarioBase, percentualPericulosidade: pMonthly.percentualPericulosidade, outrosProventosTributaveis: pMonthly.outrosProventosTributaveis, numeroDependentes: pMonthly.numeroDependentes, valorDesjejumDia: pMonthly.valorDesjejumDia, valorTransporteDia: pMonthly.valorTransporteDia, diasTrabalhados: pMonthly.diasTrabalhados, horasTrabalhadas: pMonthly.hoursTrabalhadas, jornadaMensalHoras: pMonthly.jornadaMensalHoras };
                                    pushEntriesToMonth(md, rId, vals, meta);
                                }
                            } else {
                                const metaNow = { salarioBase: params.salarioBase, percentualPericulosidade: params.percentualPericulosidade, outrosProventosTributaveis: params.outrosProventosTributaveis, numeroDependentes: params.numeroDependentes, valorDesjejumDia: params.valorDesjejumDia, valorTransporteDia: params.valorTransporteDia, diasTrabalhados: params.diasTrabalhados, horasTrabalhadas: params.hoursTrabalhadas, jornadaMensalHoras: params.jornadaMensalHoras };
                                pushEntriesToMonth(currentMonthData, null, { salarioLiquido, beneficiosVT, beneficiosVR, valorHorasExtras }, metaNow);
                            }
                            try { await storage.saveData(state.appData); showToast('Salário salvo com sucesso!', 'bg-green-600'); } catch(e){ console.error('save new salary', e); showToast('Falha ao salvar salário no Firebase.', 'bg-red-600'); }
                        }

                        try {
                            await storage.saveData(state.appData);
                            showToast('Salário salvo com sucesso!', 'bg-green-600');
                        } catch (err) {
                            console.error('Erro ao salvar salário:', err);
                            showToast('Falha ao salvar salário no Firebase.', 'bg-red-600');
                        }

                        // Optionally show a quick details toast with totals (short)
                        // showToast(`Líquido: ${formatCurrency(salarioLiquido)} • Benefícios: ${formatCurrency(beneficiosTotais)} • Extras: ${formatCurrency(valorHorasExtras)}`, 'bg-blue-600');

                    } catch (err) {
                        console.error('Erro no processamento do salário:', err);
                        showToast('Erro ao processar salário: ' + (err && err.message ? err.message : ''), 'bg-red-600');
                    }
                } else {
                    await saveTransaction(transactionData, type, id);
                }
            } catch (e) {
                console.error('Erro ao processar formulário:', e);
                showToast('Erro ao salvar transação: ' + (e && e.message ? e.message : ''), 'bg-red-600');
            }

            closeModal('transaction-modal');
            render();
        }

            // --- VR inline-edit helpers ---
            function startInlineVREdit(el, vrId) {
                try {
                    if (!el) return;
                    const current = el.textContent || '';
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = '0.01';
                    input.value = parseFloat(String(current).replace(/[R$\.\s]/g, '').replace(',', '.')) || 0;
                    input.className = 'inline-vr-input border px-1 py-0 rounded text-right';
                    input.style.minWidth = '80px';
                    el.replaceWith(input);
                    input.focus();
                    input.select();
                    const commit = async () => {
                        const v = parseFloat(input.value) || 0;
                        await commitInlineVREdit(vrId, v, input);
                    };
                    input.addEventListener('blur', commit);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { input.blur(); }
                        if (e.key === 'Escape') { render(); }
                    });
                } catch(e){ console.error('startInlineVREdit', e); }
            }

            async function commitInlineVREdit(vrId, newAmount, inputEl) {
                try {
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vrLedger)) md.vrLedger = [];
                    const idx = md.vrLedger.findIndex(l => l.id === vrId);
                    if (idx === -1) return render();
                    const entry = md.vrLedger[idx];
                    const oldAmount = entry.amount || 0;
                    entry.amount = Math.round((Number(newAmount) + Number.EPSILON) * 100) / 100;
                    try { await storage.saveData(state.appData); } catch(e){ console.error('commitInlineVREdit save', e); }
                    // Inline edits should not forcibly apply to future recurrences; explicit action via modal will allow that.
                    render();
                } catch(e){ console.error('commitInlineVREdit', e); }
            }

            function applyToFutureVREntries(recurringId, newAmount) {
                try {
                    Object.keys(state.appData.data).forEach(year => {
                        Object.keys(state.appData.data[year]).forEach(month => {
                            const md = state.appData.data[year][month];
                            if (!md || !Array.isArray(md.vrLedger)) return;
                            md.vrLedger = md.vrLedger.map(l => {
                                if (l.recurringId === recurringId) {
                                    return { ...l, amount: newAmount };
                                }
                                return l;
                            });
                        });
                    });
                    try { storage.saveData(state.appData); } catch(e){ console.error('applyToFutureVREntries save', e); }
                    showToast('Alterações aplicadas às recorrências futuras.', 'bg-green-600');
                } catch(e){ console.error('applyToFutureVREntries', e); }
            }

            // Delete a VR ledger entry by id. If it's recurring, ask to remove future recurrences as well.
            async function deleteVRLedgerEntry(id, yearContext, monthContext) {
                try {
                    if (!id) return;
                    const y = yearContext || state.currentDate.getFullYear();
                    const m = monthContext || (state.currentDate.getMonth() + 1);
                    const monthData = getCurrentMonthData(new Date(y, m - 1, 1));
                    if (!monthData || !Array.isArray(monthData.vrLedger)) return;
                    const idx = monthData.vrLedger.findIndex(v => v.id === id);
                    if (idx === -1) return;
                    const entry = monthData.vrLedger[idx];
                    let removeFuture = false;
                    if (entry && entry.recurringId) {
                        removeFuture = confirm('Este VR é recorrente. Deseja excluir também as recorrências futuras? (OK = Sim)');
                    }
                    // remove this entry from current month
                    monthData.vrLedger.splice(idx, 1);
                    // if removeFuture and entry.recurringId, sweep future months
                    if (removeFuture && entry && entry.recurringId) {
                        const rid = entry.recurringId;
                        const currentMonthStart = new Date(y, m - 1, 1);
                        Object.keys(state.appData.data).forEach(yearKey => {
                            Object.keys(state.appData.data[yearKey]).forEach(monthKey => {
                                const yearNum = Number(yearKey);
                                const monthNum = Number(monthKey);
                                const candidate = new Date(yearNum, monthNum - 1, 1);
                                if (candidate >= currentMonthStart) {
                                    const md = state.appData.data[yearKey][monthKey];
                                    if (md && Array.isArray(md.vrLedger)) {
                                        md.vrLedger = md.vrLedger.filter(v => v.recurringId !== rid);
                                    }
                                }
                            });
                        });
                    }
                    try { await storage.saveData(state.appData); showToast('VR excluído.'); } catch (e) { console.error('delete vr save', e); showToast('Falha ao excluir VR.', 'bg-red-600'); }
                } catch (e) { console.error('deleteVRLedgerEntry', e); }
            }

            // Delete VT ledger entry by id (mirror VR behavior)
            async function deleteVTLedgerEntry(id, yearContext, monthContext) {
                try {
                    if (!id) return;
                    const y = yearContext || state.currentDate.getFullYear();
                    const m = monthContext || (state.currentDate.getMonth() + 1);
                    const monthData = getCurrentMonthData(new Date(y, m - 1, 1));
                    if (!monthData || !Array.isArray(monthData.vtLedger)) return;
                    const idx = monthData.vtLedger.findIndex(v => v.id === id);
                    if (idx === -1) return;
                    const entry = monthData.vtLedger[idx];
                    let removeFuture = false;
                    if (entry && entry.recurringId) {
                        removeFuture = confirm('Este VT é recorrente. Deseja excluir também as recorrências futuras? (OK = Sim)');
                    }
                    monthData.vtLedger.splice(idx, 1);
                    if (removeFuture && entry && entry.recurringId) {
                        const rid = entry.recurringId;
                        const currentMonthStart = new Date(y, m - 1, 1);
                        Object.keys(state.appData.data).forEach(yearKey => {
                            Object.keys(state.appData.data[yearKey]).forEach(monthKey => {
                                const yearNum = Number(yearKey);
                                const monthNum = Number(monthKey);
                                const candidate = new Date(yearNum, monthNum - 1, 1);
                                if (candidate >= currentMonthStart) {
                                    const md = state.appData.data[yearKey][monthKey];
                                    if (md && Array.isArray(md.vtLedger)) {
                                        md.vtLedger = md.vtLedger.filter(v => v.recurringId !== rid);
                                    }
                                }
                            });
                        });
                    }
                    try { await storage.saveData(state.appData); showToast('VT excluído.'); } catch (e) { console.error('delete vt save', e); showToast('Falha ao excluir VT.', 'bg-red-600'); }
                } catch (e) { console.error('deleteVTLedgerEntry', e); }
            }

            // Open the VR modal to edit a ledger entry
            function openVREdit(id) {
                try {
                    const modal = document.getElementById('vr-modal');
                    if (!modal) return;
                    const md = getCurrentMonthData();
                    const entry = (md.vrLedger || []).find(v => v.id === id) || null;
                    if (entry) {
                        document.getElementById('vr-entry-id').value = entry.id || '';
                        document.getElementById('vr-entry-desc').value = entry.description || 'Benefício - VR';
                        document.getElementById('vr-entry-amount').value = entry.amount || 0;
                    } else {
                        document.getElementById('vr-entry-id').value = '';
                        document.getElementById('vr-entry-desc').value = 'Benefício - VR';
                        document.getElementById('vr-entry-amount').value = '';
                    }
                    try { modal.showModal(); } catch(e){ console.error('openVREdit showModal', e); }
                } catch (e) { console.error('openVREdit', e); }
            }

            function closeVRModal() {
                try { const m = document.getElementById('vr-modal'); if (m && typeof m.close === 'function') m.close(); } catch(e) { console.error('closeVRModal', e); }
            }

            async function saveVRLedgerEntry() {
                try {
                    const id = document.getElementById('vr-entry-id').value;
                    const desc = document.getElementById('vr-entry-desc').value || 'Benefício - VR';
                    const amount = parseFloat(document.getElementById('vr-entry-amount').value) || 0;
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vrLedger)) md.vrLedger = [];
                    if (id) {
                        const idx = md.vrLedger.findIndex(v => v.id === id);
                        if (idx > -1) {
                            // Update only this month. VR edits are independent by default.
                            md.vrLedger[idx].description = desc;
                            md.vrLedger[idx].amount = amount;
                        }
                    } else {
                        md.vrLedger.push({ id: generateUUID(), description: desc, amount: amount, recurringId: null, isRecurring: false });
                    }
                    await storage.saveData(state.appData);
                    closeVRModal();
                    render();
                    showToast('VR salvo.', 'bg-green-600');
                } catch (e) { console.error('saveVRLedgerEntry', e); showToast('Falha ao salvar VR.', 'bg-red-600'); }
            }

            // VR Usage edit helpers
            function openVRUsageEdit(id) {
                try {
                    const md = getCurrentMonthData();
                    const entry = (md.vrUsage || []).find(u => u.id === id);
                    const modal = document.getElementById('vr-usage-modal');
                    if (!modal) return;
                    if (entry) {
                        document.getElementById('vr-usage-id').value = entry.id || '';
                        document.getElementById('vr-usage-desc').value = entry.description || '';
                        document.getElementById('vr-usage-amount').value = entry.amount || 0;
                    } else {
                        document.getElementById('vr-usage-id').value = '';
                        document.getElementById('vr-usage-desc').value = '';
                        document.getElementById('vr-usage-amount').value = '';
                    }
                    try { modal.showModal(); } catch(e) { console.error('openVRUsageEdit showModal', e); }
                } catch(e) { console.error('openVRUsageEdit', e); }
            }

            function closeVRUsageModal() {
                try { const m = document.getElementById('vr-usage-modal'); if (m && typeof m.close === 'function') m.close(); } catch(e) { console.error('closeVRUsageModal', e); }
            }

            async function saveVRUsageEdit(e) {
                try {
                    if (e && typeof e.preventDefault === 'function') e.preventDefault();
                    const id = document.getElementById('vr-usage-id').value;
                    const desc = document.getElementById('vr-usage-desc').value || '';
                    const amount = parseFloat(document.getElementById('vr-usage-amount').value) || 0;
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vrUsage)) md.vrUsage = [];
                    // Validate against available VR balance for this month.
                    const ledgerTotal = (Array.isArray(md.vrLedger) ? md.vrLedger.reduce((s,l) => s + (Number(l && l.amount) || 0), 0) : 0);
                    const currentUsageExcludingThis = (md.vrUsage || []).reduce((s,u) => s + (Number(u && u.amount) || 0), 0) - ((id && md.vrUsage.find(u => u.id === id)) ? Number(md.vrUsage.find(u => u.id === id).amount || 0) : 0);
                    const projectedUsage = Math.round((currentUsageExcludingThis + amount) * 100) / 100;
                    if (projectedUsage > Math.round((ledgerTotal + Number.EPSILON) * 100) / 100) {
                        // Exceeds available VR balance — show inline error and abort
                        // Use transaction error area if transaction modal is open, otherwise toast
                        try {
                            setTransactionError('Valor superior ao saldo disponível de VR para este mês. Verifique o saldo no card de VR.');
                        } catch(e) { /* ignore */ }
                        showToast('Saldo de VR insuficiente para esta edição.', 'bg-red-600');
                        return; // abort save
                    }

                    if (id) {
                        const idx = md.vrUsage.findIndex(u => u.id === id);
                        if (idx > -1) {
                            md.vrUsage[idx].description = desc;
                            md.vrUsage[idx].amount = amount;
                        }
                    } else {
                        md.vrUsage.push({ id: generateUUID(), description: desc, amount: amount, date: new Date().toISOString() });
                    }
                    try { await storage.saveData(state.appData); showToast('Compra VR salva.', 'bg-green-600'); } catch(e) { console.error('saveVRUsageEdit save', e); showToast('Falha ao salvar compra VR.', 'bg-red-600'); }
                    closeVRUsageModal();
                    render();
                } catch(e) { console.error('saveVRUsageEdit', e); }
            }

            // VT Ledger helpers
            function openVTEdit(id) {
                try {
                    const modal = document.getElementById('vt-modal');
                    if (!modal) return;
                    const md = getCurrentMonthData();
                    const entry = (md.vtLedger || []).find(v => v.id === id) || null;
                    if (entry) {
                        document.getElementById('vt-entry-id').value = entry.id || '';
                        document.getElementById('vt-entry-desc').value = entry.description || 'Benefício - VT';
                        document.getElementById('vt-entry-amount').value = entry.amount || 0;
                    } else {
                        document.getElementById('vt-entry-id').value = '';
                        document.getElementById('vt-entry-desc').value = 'Benefício - VT';
                        document.getElementById('vt-entry-amount').value = '';
                    }
                    try { modal.showModal(); } catch(e){ console.error('openVTEdit showModal', e); }
                } catch (e) { console.error('openVTEdit', e); }
            }

            function closeVTModal() {
                try { const m = document.getElementById('vt-modal'); if (m && typeof m.close === 'function') m.close(); } catch(e) { console.error('closeVTModal', e); }
            }

            async function saveVTLedgerEntry() {
                try {
                    const id = document.getElementById('vt-entry-id').value;
                    const desc = document.getElementById('vt-entry-desc').value || 'Benefício - VT';
                    const amount = parseFloat(document.getElementById('vt-entry-amount').value) || 0;
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vtLedger)) md.vtLedger = [];
                    if (id) {
                        const idx = md.vtLedger.findIndex(v => v.id === id);
                        if (idx > -1) {
                            md.vtLedger[idx].description = desc;
                            md.vtLedger[idx].amount = amount;
                        }
                    } else {
                        md.vtLedger.push({ id: generateUUID(), description: desc, amount: amount, recurringId: null, isRecurring: false });
                    }
                    await storage.saveData(state.appData);
                    closeVTModal();
                    render();
                    showToast('VT salvo.', 'bg-green-600');
                } catch (e) { console.error('saveVTLedgerEntry', e); showToast('Falha ao salvar VT.', 'bg-red-600'); }
            }

            // VT Usage edit helpers
            function openVTUsageEdit(id) {
                try {
                    const md = getCurrentMonthData();
                    const entry = (md.vtUsage || []).find(u => u.id === id);
                    const modal = document.getElementById('vt-usage-modal');
                    if (!modal) return;
                    if (entry) {
                        document.getElementById('vt-usage-id').value = entry.id || '';
                        document.getElementById('vt-usage-desc').value = entry.description || '';
                        document.getElementById('vt-usage-amount').value = entry.amount || 0;
                    } else {
                        document.getElementById('vt-usage-id').value = '';
                        document.getElementById('vt-usage-desc').value = '';
                        document.getElementById('vt-usage-amount').value = '';
                    }
                    try { modal.showModal(); } catch(e) { console.error('openVTUsageEdit showModal', e); }
                } catch(e) { console.error('openVTUsageEdit', e); }
            }

            function closeVTUsageModal() {
                try { const m = document.getElementById('vt-usage-modal'); if (m && typeof m.close === 'function') m.close(); } catch(e) { console.error('closeVTUsageModal', e); }
            }

            async function saveVTUsageEdit(e) {
                try {
                    if (e && typeof e.preventDefault === 'function') e.preventDefault();
                    const id = document.getElementById('vt-usage-id').value;
                    const desc = document.getElementById('vt-usage-desc').value || '';
                    const amount = parseFloat(document.getElementById('vt-usage-amount').value) || 0;
                    const md = getCurrentMonthData();
                    if (!Array.isArray(md.vtUsage)) md.vtUsage = [];
                    // Validate against available VT balance for this month.
                    const ledgerTotal = (Array.isArray(md.vtLedger) ? md.vtLedger.reduce((s,l) => s + (Number(l && l.amount) || 0), 0) : 0);
                    const currentUsageExcludingThis = (md.vtUsage || []).reduce((s,u) => s + (Number(u && u.amount) || 0), 0) - ((id && md.vtUsage.find(u => u.id === id)) ? Number(md.vtUsage.find(u => u.id === id).amount || 0) : 0);
                    const projectedUsage = Math.round((currentUsageExcludingThis + amount) * 100) / 100;
                    if (projectedUsage > Math.round((ledgerTotal + Number.EPSILON) * 100) / 100) {
                        try { setTransactionError('Valor superior ao saldo disponível de VT para este mês. Verifique o saldo no card de VT.'); } catch(e) {}
                        showToast('Saldo de VT insuficiente para esta edição.', 'bg-red-600');
                        return; // abort save
                    }

                    if (id) {
                        const idx = md.vtUsage.findIndex(u => u.id === id);
                        if (idx > -1) {
                            md.vtUsage[idx].description = desc;
                            md.vtUsage[idx].amount = amount;
                        }
                    } else {
                        md.vtUsage.push({ id: generateUUID(), description: desc, amount: amount, date: new Date().toISOString() });
                    }
                    try { await storage.saveData(state.appData); showToast('Compra VT salva.', 'bg-green-600'); } catch(e) { console.error('saveVTUsageEdit save', e); showToast('Falha ao salvar compra VT.', 'bg-red-600'); }
                    closeVTUsageModal();
                    render();
                } catch(e) { console.error('saveVTUsageEdit', e); }
            }

        // Export public API
        return {
            init,
            // VR helpers
            openVRUsageEdit,
            closeVRUsageModal,
            saveVRUsageEdit,
            saveVRLedgerEntry,
            closeVRModal,
            // VT helpers
            openVTUsageEdit,
            closeVTUsageModal,
            saveVTUsageEdit,
            saveVTLedgerEntry,
            closeVTModal,
            openVTEdit
        };
    })(); // Close App IIFE and assign to App

    // Inicializa a aplicação quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', () => {
        if (App && typeof App.init === 'function') {
            App.init();
            // Attach VR modal buttons after init so elements are available
            try {
                const vrSaveBtn = document.getElementById('vr-entry-save'); if (vrSaveBtn) vrSaveBtn.addEventListener('click', (e) => { e.preventDefault(); App.saveVRLedgerEntry(); });
                const vrCancel = document.getElementById('vr-entry-cancel'); if (vrCancel) vrCancel.addEventListener('click', (e) => { e.preventDefault(); document.getElementById('vr-entry-id').value = ''; document.getElementById('vr-entry-desc').value = ''; document.getElementById('vr-entry-amount').value = ''; });
                const vrClose = document.getElementById('close-vr-modal'); if (vrClose) vrClose.addEventListener('click', () => App.closeVRModal());
                const vruSave = document.getElementById('vr-usage-save'); if (vruSave) vruSave.addEventListener('click', (e) => { e.preventDefault(); App.saveVRUsageEdit(e); });
                const vruCancel = document.getElementById('vr-usage-cancel'); if (vruCancel) vruCancel.addEventListener('click', (e) => { e.preventDefault(); App.closeVRUsageModal(); });
                const vruClose = document.getElementById('vr-usage-close'); if (vruClose) vruClose.addEventListener('click', () => App.closeVRUsageModal());
                // Ensure form submission (Enter key) does not trigger a full page submit
                const vruForm = document.getElementById('vr-usage-form'); if (vruForm) vruForm.addEventListener('submit', (e) => { e.preventDefault(); App.saveVRUsageEdit(e); });
                // Also protect VR ledger form (vr-entry-form) from default submit behavior
                const vrEntryForm = document.getElementById('vr-entry-form'); if (vrEntryForm) vrEntryForm.addEventListener('submit', (e) => { e.preventDefault(); App.saveVRLedgerEntry(); });
                // VT modal bindings
                const vtSaveBtn = document.getElementById('vt-entry-save'); if (vtSaveBtn) vtSaveBtn.addEventListener('click', (e) => { e.preventDefault(); App.saveVTLedgerEntry(); });
                const vtCancel = document.getElementById('vt-entry-cancel'); if (vtCancel) vtCancel.addEventListener('click', (e) => { e.preventDefault(); document.getElementById('vt-entry-id').value = ''; document.getElementById('vt-entry-desc').value = ''; document.getElementById('vt-entry-amount').value = ''; });
                const vtClose = document.getElementById('close-vt-modal'); if (vtClose) vtClose.addEventListener('click', () => App.closeVTModal());
                const vtuSave = document.getElementById('vt-usage-save'); if (vtuSave) vtuSave.addEventListener('click', (e) => { e.preventDefault(); App.saveVTUsageEdit(e); });
                const vtuCancel = document.getElementById('vt-usage-cancel'); if (vtuCancel) vtuCancel.addEventListener('click', (e) => { e.preventDefault(); App.closeVTUsageModal(); });
                const vtuClose = document.getElementById('vt-usage-close'); if (vtuClose) vtuClose.addEventListener('click', () => App.closeVTUsageModal());
                const vtuForm = document.getElementById('vt-usage-form'); if (vtuForm) vtuForm.addEventListener('submit', (e) => { e.preventDefault(); App.saveVTUsageEdit(e); });
                const vtEntryForm = document.getElementById('vt-entry-form'); if (vtEntryForm) vtEntryForm.addEventListener('submit', (e) => { e.preventDefault(); App.saveVTLedgerEntry(); });
                // Mobile FAB: delegate to existing add-transaction button to preserve behavior
                try {
                    const mobileFab = document.getElementById('mobile-add-transaction-fab');
                    const desktopAddBtn = document.getElementById('add-transaction-btn');
                    if (mobileFab && desktopAddBtn) {
                        mobileFab.addEventListener('click', (e) => {
                            // If on mobile, simulate click on the main add button which opens the modal
                            if (window.innerWidth <= 639) {
                                try { desktopAddBtn.click(); } catch (err) { openModal('expenses'); }
                            } else {
                                // hide mobile FAB on desktop
                                mobileFab.style.display = 'none';
                            }
                        });
                    }
                } catch(e) { console.error('attach mobile FAB', e); }
            } catch(e) { console.error('attach vr modal buttons', e); }
        }
    });
    </script>
    <!-- Toasts -->
    <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded shadow-lg z-50 hidden" role="status" aria-live="polite"></div>
    <!-- Mobile Bottom Navigation -->
    <nav id="mobile-bottom-nav" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-white rounded-full shadow-lg px-3 py-2 z-50 gap-3 hidden">
        <button data-view="dashboard" class="mobile-nav-btn p-2 rounded-full" title="Visão Geral"><span class="material-symbols-outlined">dashboard</span></button>
        <button data-view="credit-cards" class="mobile-nav-btn p-2 rounded-full" title="Faturas"><span class="material-symbols-outlined">credit_card</span></button>
        <button data-view="investments" class="mobile-nav-btn p-2 rounded-full" title="Investimentos"><span class="material-symbols-outlined">trending_up</span></button>
    </nav>
    <!-- Mobile Floating Add Transaction Button -->
    <button id="mobile-add-transaction-fab" aria-label="Adicionar transação" title="Nova transação">+
    </button>
</body>
</html>